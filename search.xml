<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MarkDown语法</title>
      <link href="posts/730dd3ed.html"/>
      <url>posts/730dd3ed.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>“你和萤火虫有两个共同点，在我的眼里都会发光，同时，都已经很多年没见了。”</p><p align="right">——《夜、萤火虫和你》网易云音乐热评</p></blockquote>    <div id="aplayer-phMJMUkr" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="509720124" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><h2 id="1-多级标题"><a href="#1-多级标题" class="headerlink" title="1. 多级标题"></a>1. 多级标题</h2><p>方法一： <code>#</code>加上<code>空格</code></p><p><code># 这是第一级标题</code></p><p><code>## 这是第二级标题</code></p><p>方法二：快捷键：<code>ctrl+ 1~6</code>       清除<code>ctrl+ 0</code></p><p>方法三：选择文字后点击菜单栏<code>段落</code>选择标题级数</p><h2 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h2><h3 id="1-有序列表"><a href="#1-有序列表" class="headerlink" title="1. 有序列表"></a>1. 有序列表</h3><p>语法： 数字加<code>.</code>加空格   <code>1. </code>      </p><p>快捷键：<code>ctrl+shift+[</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">行末回车序号会自动添加  回车加回车会取消序号</span><br><span class="line">行末↓，序号不自动添加</span><br></pre></td></tr></table></figure><p>有序列表中嵌套有序列表 <code> -&gt;</code>选择后按<code>tab</code>键实现降级</p><p>按<code>shift+tab</code>实现升级</p><h3 id="2-无序列表"><a href="#2-无序列表" class="headerlink" title="2. 无序列表"></a>2. 无序列表</h3><p>语法：加空格  / -加空格    <code>* </code></p><p>快捷键：<code>ctrl+shift+]</code></p><ol><li><p>青菜</p></li><li><p>水果</p><ul><li>苹果</li><li>菠萝</li></ul><p>选择后按<code>tab</code>实现降级</p></li></ol><h3 id="3-有序与无序的切换"><a href="#3-有序与无序的切换" class="headerlink" title="3. 有序与无序的切换"></a>3. 有序与无序的切换</h3><p>有序快捷键：<code>ctrl+shift+[</code></p><p>无序快捷键：<code>ctrl+shift+]</code></p><p>配合<code>tab</code>和<code>shift+tab</code></p><p>实现无序与有序的交错使用</p><p>有序与无序也可以选择后在菜单<code>段落</code>中选择<code>有序列表</code>和<code>无序列表</code></p><h3 id="4-任务列表"><a href="#4-任务列表" class="headerlink" title="4. 任务列表"></a>4. 任务列表</h3><p>  语法：<code>-</code>加<code>空格</code>加<code>[</code>加<code>空格</code>加<code>]</code>加<code>空格</code>       <code>- [ ] </code></p><p>  还需在开头，如果前面有文字就无法实现</p><ul><li><input disabled="" type="checkbox"> 任务一</li><li><input disabled="" type="checkbox"> 任务二</li><li><input disabled="" type="checkbox"> 任务三</li></ul><p>  回车加回车取消任务列表</p><p>  方法二：选择后点击菜单<code>段落</code>选择<code>任务列表</code></p><h2 id="3-插入表格"><a href="#3-插入表格" class="headerlink" title="3. 插入表格"></a>3. 插入表格</h2><p>语法：<code>|</code>加<code>xx</code>加<code>|</code>…然后回车就行</p><p>快捷键：<code>ctrl+t</code></p><p>在表格中点击任意单元通过快捷键<code>ctrl+回车</code>即可添加新的一行</p><h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><h3 id="1-行内代码"><a href="#1-行内代码" class="headerlink" title="1. 行内代码"></a>1. 行内代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过两个`  可以将选中的文字转为代码，</span><br><span class="line">也可选择文字后用快捷键   ==ctrl+shift+`==快捷转化为代码</span><br></pre></td></tr></table></figure><h3 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2. 代码块"></a>2. 代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">创建方式：```java</span><br><span class="line">ctrl+shift+k可以快捷创建代码块，在右下角选择语言</span><br></pre></td></tr></table></figure><h2 id="5-插入图片"><a href="#5-插入图片" class="headerlink" title="5. 插入图片"></a>5. 插入图片</h2><p>粗暴的直接拖拽</p><p>语法创建：<code>![自定义图片名字](地址)</code></p><p>快捷键：<code>ctrl+shift+i</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![cool](https:<span class="comment">//...)</span></span><br></pre></td></tr></table></figure><h2 id="6-加粗，倾斜，删除线，下划线，高亮，上下标"><a href="#6-加粗，倾斜，删除线，下划线，高亮，上下标" class="headerlink" title="6. 加粗，倾斜，删除线，下划线，高亮，上下标"></a>6. 加粗，倾斜，删除线，下划线，高亮，上下标</h2><ul><li><p><code>**加粗**</code>                       <strong>加粗</strong></p></li><li><p><code>*倾斜*</code>                            <em>倾斜</em></p></li><li><p><code>加粗倾斜</code>                         <em><strong>加粗倾斜</strong></em></p></li><li><p><code>~~删除线~~</code>                     <del>删除线</del></p></li><li><p>下划线快捷键<code>ctrl+u</code>     <u>下划线</u></p></li><li><p><code>==高亮==</code>                         ==高亮== （不过好像在网页上并未显示出高亮效果）</p></li><li><p><code>^上标^</code>                             ^上标^</p></li><li><p><code>~下标~</code>                             <del>下标</del>      </p></li><li><p><code>---</code>                                分割线       也可<code>***</code>,<code>___</code></p></li></ul><hr><h2 id="7-引用，表情符号，实空心点"><a href="#7-引用，表情符号，实空心点" class="headerlink" title="7. 引用，表情符号，实空心点"></a>7. 引用，表情符号，实空心点</h2><ul><li>引用1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用</span><br><span class="line">&gt;&gt;第二级</span><br><span class="line">&gt;&gt;&gt;第三级</span><br></pre></td></tr></table></figure><blockquote><p>引用</p><blockquote><p>第二级</p><blockquote><p>第三级</p></blockquote></blockquote></blockquote><ul><li>引用2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&quot;试试看喽&quot;</span><br></pre></td></tr></table></figure><blockquote><p>“试试看喽”</p></blockquote><ul><li>表情符号</li></ul><p>输入<code>:xxx:</code> </p><p>一些常用例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile:  :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary:</span><br><span class="line"></span><br><span class="line">:+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:</span><br></pre></td></tr></table></figure><p>:smile:  :laughing:  :dizzy_face:   :sob:   :sweat_smile:   :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger:</p><ul><li><p>实空心点  </p></li><li><p>+号和空格</p><ul><li>回车，再回车，可以消除实心点，tab再+号和空格就是空心点</li></ul></li></ul><p>也可以<code>-</code>或者<code>*</code></p><h2 id="8-内外部跳转"><a href="#8-内外部跳转" class="headerlink" title="8. 内外部跳转"></a>8. 内外部跳转</h2><p> 快捷键：<code>ctrl+k</code></p><h3 id="1-外部跳转–超链接"><a href="#1-外部跳转–超链接" class="headerlink" title="1. 外部跳转–超链接"></a>1. 外部跳转–超链接</h3><p>格式：<code>[xxx]()</code>  </p><p><a href="www.baidu.com">百度</a></p><h3 id="2-内部跳转"><a href="#2-内部跳转" class="headerlink" title="2. 内部跳转"></a>2. 内部跳转</h3><p>格式：<code>[xxx](#要去的目的地--标题）</code></p><p><a href="#3.%E6%8F%92%E5%85%A5%E8%A1%A8%E6%A0%BC">我要去插入表格那里</a></p><h3 id="3-自动链接"><a href="#3-自动链接" class="headerlink" title="3. 自动链接"></a>3. 自动链接</h3><p>使用 <code>&lt;&gt;</code> 包括的 URL 或邮箱地址会被自动转换为超链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;https:&#x2F;&#x2F;www.baidu.com&gt;</span><br><span class="line"></span><br><span class="line">&lt;123@email.com&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.baidu.com/">https://www.baidu.com</a></p><p><a href="mailto:&#49;&#50;&#x33;&#64;&#101;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;">&#49;&#50;&#x33;&#64;&#101;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;</a></p><h2 id="9-快捷键汇总"><a href="#9-快捷键汇总" class="headerlink" title="9. 快捷键汇总"></a>9. 快捷键汇总</h2><p><code>Ctrl 0</code> 到 ：普通文本、一级～六级标题；<code>Ctrl+1~6</code></p><p><code>Ctrl B</code>：加粗</p><p><code>Ctrl I</code>：斜体</p><p><code>Ctrl U</code>：下划线</p><p><code>Shift Alt 5</code>：删除线</p><p><code>Shift+Ctrl+Tab键上面那个键</code>：行内代码块</p><p><code>Ctrl K</code>：超链接</p><p><code>Ctrl T</code>：表格</p><p><code>Ctrl Shift Q</code>：引用</p><p><code>Shift Ctrl I</code>：图片</p><p><code>Shift Ctrl M</code>：公式块</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建与优化</title>
      <link href="posts/86749132.html"/>
      <url>posts/86749132.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>由于不可控因素导致时常重装系统，每次都去重新搭建Hexo很是麻烦，所以我简单的记录下了重要的几部操作，以便恢复到之前的状态。</p></blockquote><h2 id="搭建篇"><a href="#搭建篇" class="headerlink" title="搭建篇"></a>搭建篇</h2><h4 id="安装Git和Node-js"><a href="#安装Git和Node-js" class="headerlink" title="安装Git和Node.js"></a>安装Git和Node.js</h4><p>去官网下载即可<a href="https://git-scm.com/downloads">Git</a>、<a href="https://nodejs.org/en/download/">Node.js</a></p><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo框架的安装</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="comment"># 等上一个命令完成后，在输入下面的命令</span></span><br><span class="line">hexo init 新建文件夹的名称  <span class="comment">#初始化文件夹</span></span><br><span class="line"><span class="built_in">cd</span> 新建文件夹的名称</span><br><span class="line">npm install  <span class="comment"># 安装博客所需要的依赖文件</span></span><br></pre></td></tr></table></figure><h4 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;此处填写你注册时的用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;此处填写你注册时的邮箱&quot;</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><p>文本编辑器打开<code>C:/users/[username]/.ssh</code>里面的<code>id_rsa.pub</code>，复制后加到GitHub中(Settings-&gt;SSH keys-&gt;New SSH key)</p><p>验证是否成功方法: <code>ssh -T git@github.com</code></p><h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>在站点根目录的 source 目录下新建一个 CNAME 文件，里面写入自己的域名</p><p>在<code>_config.yml</code>中配置 <code>skip_render: CNAME</code></p><h2 id="主题篇-Butterfly"><a href="#主题篇-Butterfly" class="headerlink" title="主题篇(Butterfly)"></a>主题篇(Butterfly)</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><strong>对应主题文档</strong>：<a href="https://butterfly.js.org/posts/21cfbf15/">https://butterfly.js.org/posts/21cfbf15/</a></p><p>安装指令：<code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code></p><h4 id="pug-以及-stylus-的渲染器-主题需要"><a href="#pug-以及-stylus-的渲染器-主题需要" class="headerlink" title="pug 以及 stylus 的渲染器(主题需要)"></a>pug 以及 stylus 的渲染器(主题需要)</h4><p>安装指令：<code>npm install hexo-renderer-pug hexo-renderer-stylus --save</code></p><h4 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h4><p>插件<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">文档</a></p><p>安装指令：<code>npm install --save hexo-tag-aplayer</code></p><h4 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h4><p>插件<a href="https://github.com/jerryc127/butterfly-plugins/tree/main/hexo-butterfly-douban">文档</a></p><p>安装指令：<code>npm install hexo-butterfly-douban --save</code></p><h4 id="图库"><a href="#图库" class="headerlink" title="图库"></a>图库</h4><p>图库页面只是普通的页面，需<code>hexo n page xx</code>，然后使用标签外挂<code>galleyGroup</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span><br><span class="line">&#123;% galleryGroup <span class="string">&#x27;name&#x27;</span> <span class="string">&#x27;description&#x27;</span> <span class="string">&#x27;link&#x27;</span> <span class="string">&#x27;img-url&#x27;</span> %&#125;</span><br><span class="line">&#123;% galleryGroup <span class="string">&#x27;name&#x27;</span> <span class="string">&#x27;description&#x27;</span> <span class="string">&#x27;link&#x27;</span> <span class="string">&#x27;img-url&#x27;</span> %&#125;</span><br><span class="line">&#123;% galleryGroup <span class="string">&#x27;name&#x27;</span> <span class="string">&#x27;description&#x27;</span> <span class="string">&#x27;link&#x27;</span> <span class="string">&#x27;img-url&#x27;</span> %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>子页面也是普通的页面，只需<code>hexo n page xx </code>，然后使用标签外挂<code>gallery</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown的图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><p>子页面需整个放到父页面文件夹中去</p><h4 id="说说"><a href="#说说" class="headerlink" title="说说"></a>说说</h4><p>插件<a href="https://github.com/jerryc127/butterfly-plugins/tree/main/hexo-butterfly-artitalk">文档</a></p><p>安装指令：<code>npm install hexo-butterfly-artitalk</code></p><h4 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h4><p>安装指令：<code>npm install hexo-generator-index --save</code></p><h4 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h4><p>安装指令：<code>npm install hexo-generator-search --save</code>并在主题配置文件中打开对应功能</p><h4 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h4><p>安装指令：<code>npm install hexo-wordcount --save</code>并在主题配置文件中打开对应功能</p><h4 id="文章生成永久url连接"><a href="#文章生成永久url连接" class="headerlink" title="文章生成永久url连接"></a>文章生成永久url连接</h4><p>安装指令：<code>npm install hexo-abbrlink --save</code>并更改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#permalink: :year/:month/:day/:title/</span></span><br><span class="line">permalink: post/:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  rep: hex    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure><h4 id="评论-twikoo"><a href="#评论-twikoo" class="headerlink" title="评论(twikoo)"></a>评论(twikoo)</h4><p>参考<a href="https://imlql.cn/post/bb283ed3.html">https://imlql.cn/post/bb283ed3.html</a></p><h4 id="标签外挂"><a href="#标签外挂" class="headerlink" title="标签外挂"></a>标签外挂</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note succes %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note succes modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><h4 id="发布插件"><a href="#发布插件" class="headerlink" title="发布插件"></a>发布插件</h4><p>安装指令：<code>npm install hexo-deployer-git --save</code></p><h2 id="优化篇"><a href="#优化篇" class="headerlink" title="优化篇"></a>优化篇</h2><h5 id="CDN-加速"><a href="#CDN-加速" class="headerlink" title="CDN 加速"></a>CDN 加速</h5><p>本地新建一个文件夹，在文件夹内依次执行下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin 你新建仓库的HTTP或者SSH地址链接</span><br><span class="line">git pull origin master <span class="comment">#将仓库拉取到本地文件夹</span></span><br></pre></td></tr></table></figure><p>放入文件后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .    <span class="comment">#(.表示所有的)</span></span><br><span class="line">git commit -m <span class="string">&#x27;添加文件内容描述&#x27;</span> </span><br><span class="line">git push origin master   <span class="comment">#将本地仓库文件推送到GitHub新建的仓库</span></span><br></pre></td></tr></table></figure><p>引用方法</p><p><a href="https://cdn.jsdelivr.net/gh/">https://cdn.jsdelivr.net/gh/</a> 用户名 / 仓库名 @版本号 / 文件路径</p><p>之后的修改方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;描述内容&#x27;</span></span><br><span class="line">git push origin master  <span class="comment"># 推送到GitHub仓库</span></span><br></pre></td></tr></table></figure><h5 id="图床搭建"><a href="#图床搭建" class="headerlink" title="图床搭建"></a>图床搭建</h5><p>生成Token：settings-&gt; Developer settings-&gt;Personal access token,勾选仓库权限</p><p>安装PicGo：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p><img src="https://cdn.jsdelivr.net/gh/keysuri/img/postimages/Hexo%E6%8C%87%E4%BB%A4-1.png"></p><ul><li>设定仓库名：这个是新建仓库的名称，此处填写格式 username/repo。</li><li>设定分支名：master</li><li>设定 Token：填写得到的 Token</li><li>指定存储路径：自定义，例：images/，相当于在刚刚新建的仓库下新建了该文件夹。</li><li>设定自定义域名：格式：<a href="https://cdn.jsdelivr.net/gh/username/repo">https://cdn.jsdelivr.net/gh/username/repo</a></li></ul><p>引用方式：<a href="https://cdn.jsdelivr.net/gh/username/%E4%BB%93%E5%BA%93%E5%90%8D@%E7%89%88%E6%9C%AC%E5%8F%B7/%E8%B7%AF%E5%BE%84">https://cdn.jsdelivr.net/gh/username/仓库名@版本号/路径</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="posts/4a17b156.html"/>
      <url>posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++从入门到放弃</title>
      <link href="posts/911b0ee1.html"/>
      <url>posts/911b0ee1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info modern"><p>听着这首歌我突然有种学习的欲望！还好我自制力强，把这股欲望给压下去了。</p></div>    <div id="aplayer-mHmFDJYY" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="21312101" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><h1 id="第1-7章-基本语法知识"><a href="#第1-7章-基本语法知识" class="headerlink" title="第1-7章-基本语法知识"></a>第1-7章-基本语法知识</h1><h3 id="1-布尔型：bool，取值为：true-false-。"><a href="#1-布尔型：bool，取值为：true-false-。" class="headerlink" title="1. 布尔型：bool，取值为：true / false 。"></a>1. 布尔型：<strong>bool</strong>，取值为：<strong>true / false</strong> 。</h3><p>编译系统处理逻辑型数据时，将false处理为0，true处理为1</p><p><strong>int a=1</strong>； bool flag=<strong>true</strong>; a=a+flag+true;  a=<code>3</code></p><h3 id="2-内联函数"><a href="#2-内联函数" class="headerlink" title="2. 内联函数"></a>2. <strong>内联函数</strong></h3><p><strong>内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数。</strong></p><p><strong>例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">int</span> <span class="keyword">int</span>)</span></span>;<span class="comment">//声明内置函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;<span class="comment">//定义内置函数</span></span><br><span class="line"> …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-函数的重载"><a href="#3-函数的重载" class="headerlink" title="3. 函数的重载"></a>3. <strong>函数的重载</strong></h3><p><strong>参数个数</strong>，<strong>参数类型</strong>或<strong>参数顺序</strong>三者中必须至少有一种不同</p><h3 id="4-函数模板"><a href="#4-函数模板" class="headerlink" title="4. 函数模板"></a>4. <strong>函数模板</strong></h3><p>用于函数体相同，参数个数相同而<strong>类型不同</strong>的情况。</p><p><strong>定义模板的格式：</strong></p><p><code>template &lt;typename/class T&gt;</code></p><p> <strong>通用函数定义</strong></p><p><strong>T</strong>为虚拟类型名，表示T是一个类型名，但暂未指定。等函数调用时，根据实参的类型来确定T的类型。T的名字可以自定义。</p><p><strong>注意：</strong>C++要求函数/类模板的声明和实现必须放在一个文件里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">4.10</span>，将例<span class="number">4.8</span>程序(求<span class="number">3</span>个数的最大值)改为通过模板函数实现。</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//模板声明，其中T为类型参数</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T  a, T  b, T  c)</span></span>&#123; <span class="comment">// T为虚拟的类型名</span></span><br><span class="line">    <span class="keyword">if</span>(b&gt;a) a=b;</span><br><span class="line">    <span class="keyword">if</span>(c&gt;a) a=c;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  i1=<span class="number">13</span>, i2=<span class="number">34</span>, i3=<span class="number">52</span>, i;</span><br><span class="line">    <span class="keyword">double</span>  d1=<span class="number">11.2</span>, d2=<span class="number">45.34</span>, d3=<span class="number">32.55</span>, d;</span><br><span class="line">    i=<span class="built_in">max</span>( i1, i2, i3);<span class="comment">//调用模板函数，此时T被int替代</span></span><br><span class="line">    d=<span class="built_in">max</span>( d1, d2, d3);<span class="comment">//同上，double替代T</span></span><br><span class="line">    cout&lt;&lt;“i_max=“&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;“d_max=“&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-有默认参数的函数"><a href="#5-有默认参数的函数" class="headerlink" title="5. 有默认参数的函数"></a>5. <strong>有默认参数的函数</strong></h3><p>C++中，对于多次调用同一函数时用同样的实参的情况，可以给形参一个默认值，这样形参就不必一定要从实参取值了。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">area</span><span class="params">(<span class="keyword">float</span> r=<span class="number">6.5</span>)</span></span>;<span class="comment">//指定r的默认值为6.5</span></span><br><span class="line"><span class="comment">//函数调用时实参值为6.5，则可以不必给出实参的值</span></span><br><span class="line"><span class="built_in">area</span>( ); <span class="comment">//相当于area(6.5);</span></span><br></pre></td></tr></table></figure><p>如果不想使形参取此默认值，则通过实参另行给出。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">area</span>(<span class="number">7.5</span>); <span class="comment">//形参得到的值为7.5，而不是6.5</span></span><br></pre></td></tr></table></figure><p>多个参数时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//只对形参r指定默认值12.5</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">volume</span><span class="params">(<span class="keyword">float</span> h,<span class="keyword">float</span> r=<span class="number">12.5</span>)</span></span>; </span><br><span class="line">函数调用可以采用以下形式： </span><br><span class="line"><span class="built_in">volume</span>(<span class="number">45.6</span>); <span class="comment">//相当于volume(45.6,12.5)</span></span><br><span class="line"><span class="built_in">volume</span>(<span class="number">34.2</span>,<span class="number">10.4</span>); <span class="comment">//h的值为34.2，r的值为10.4</span></span><br></pre></td></tr></table></figure><p>指定默认值的参数必须放在形参表列中的<code>最右端</code>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">float</span> a，<span class="keyword">int</span> b=<span class="number">0</span>，<span class="keyword">int</span> c，<span class="keyword">char</span> d=′a′)</span></span>;     <span class="comment">//不正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">float</span> a，<span class="keyword">int</span> c，<span class="keyword">int</span> b=<span class="number">0</span>, <span class="keyword">char</span> d=′a′)</span></span>;     <span class="comment">//正确</span></span><br><span class="line">如果调用上面的f2函数，可以采取下面的形式： </span><br><span class="line"><span class="built_in">f2</span>(<span class="number">3.5</span> , <span class="number">5</span> , <span class="number">3</span> ,  ′x′) <span class="comment">//形参的值全部从实参得到</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">3.5</span> ,  <span class="number">5</span>,  <span class="number">3</span>)<span class="comment">//最后一个形参的值取默认值′a′</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">3.5</span> ,  <span class="number">5</span>)<span class="comment">//最后两个形参的值取默认值，b=0,d=′a′</span></span><br></pre></td></tr></table></figure><ul><li><p>如果函数的定义在函数调用<code>之前</code>，则应<code>在函数定义中给出默认值</code>。如果函数的定义在函数调用<code>之后</code>，则在函数调用之前需要有<code>函数声明</code>，此时必须<code>在函数声明中给出默认值</code>，在函数定义时可以不给出默认值。</p></li><li><p><strong>一个函数不能既作为重载函数，又作为有默认参数的函数。</strong>因为当调用函数时如果少写一个参数，系统无法判定是利用重载函数还是利用默认参数的函数，出现二义性，系统无法执行。</p></li></ul><h3 id="6-字符串类与字符串变量"><a href="#6-字符串类与字符串变量" class="headerlink" title="6. 字符串类与字符串变量"></a>6. <strong>字符串类与字符串变量</strong></h3><p>C++新的数据类型：<strong>字符串类型</strong>(string类型)</p><p>必须包含头文件：<code>#include &lt;string&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string string1；   <span class="comment">//定义string1为字符串变量</span></span><br><span class="line">string string2=″China″; <span class="comment">//定义string2同时对其初始化</span></span><br></pre></td></tr></table></figure><p><strong>对字符串变量的赋值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string1=″Canada″;</span><br><span class="line">string2=string1;<span class="comment">//将”Canada”赋值给string2</span></span><br></pre></td></tr></table></figure><ul><li>在定义字符串变量时不需指定长度，长度随其中的字符串长度而改变。</li></ul><p><strong>对字符串变量中某一字符进行操作：<code>下标法</code>。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string word=″Then″; <span class="comment">//定义并初始化字符串变量</span></span><br><span class="line">word［<span class="number">2</span>］=′a′; <span class="comment">//修改后word的值为″Than″</span></span><br></pre></td></tr></table></figure><p><strong>字符串变量的输入输出</strong>:在输入输出语句中用字符串变量名，输入输出字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从键盘输入一个字符串给字符串变量string1</span></span><br><span class="line">cin&gt;&gt; string1;   </span><br><span class="line"><span class="comment">//将字符串string2输出</span></span><br><span class="line">cout&lt;&lt; string2; </span><br></pre></td></tr></table></figure><p><strong>字符串间相关操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 字符串复制用赋值号：string1=string2;</span><br><span class="line">(<span class="number">2</span>) 字符串连接用加号</span><br><span class="line">string string1=″C++″;</span><br><span class="line">string string2=″&amp; C″;</span><br><span class="line">string1=string1 + string2; <span class="comment">//连接后string1为″C++ &amp;C″。</span></span><br><span class="line">(<span class="number">3</span>) 字符串比较直接用关系运算符</span><br><span class="line">可以直接用 ==(等于)、&gt;(大于)、&lt;(小于)、!=(不等于)、&gt;=(大于或等于)、&lt;=(小于或等于)等关系运算符来进行字符串的比较</span><br></pre></td></tr></table></figure><p><strong>定义字符串数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string name［<span class="number">5</span>］; </span><br><span class="line">string name［<span class="number">5</span>］=&#123;″Zhang″,″Li″,″Fun″,″Wang″,″Tan″&#125;; </span><br></pre></td></tr></table></figure><ul><li>在字符串数组的每一个元素中存放一个字符串，而不是一个字符，这是字符串数组与字符数组的区别。</li><li>每一个字符串元素中只包含字符串本身的字符而不包括′＼0′（ ′＼0 ′是字符数组作为结束标记用的，字符串没有这个需要）。</li></ul><h3 id="7-const指针"><a href="#7-const指针" class="headerlink" title="7. const指针"></a>7. <strong>const指针</strong></h3><ul><li><strong><code>指向常量</code>的指针变量</strong></li></ul><p>定义形式： <code>const typename * varname</code></p><p><strong>它是一个指针变量</strong></p><p><strong>不允许<code>通过指针变量</code>改变它</strong><code>指向的对象的值</code>,<strong>若直接改变变量的值是可以的</strong></p><p>指针变量的值（即指向）是<code>可以改变</code>的</p><p>若要使变量的值始终不变，需将变量定义成为const变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">12</span>; <span class="keyword">const</span> <span class="keyword">int</span> b=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pa=&amp;a,   *pb=&amp;b;  </span><br><span class="line">*pa=<span class="number">15</span>; <span class="comment">//错误,不能通过指针修改a的值</span></span><br><span class="line">a=<span class="number">15</span>; <span class="comment">//正确，a为变量，可以修改其值</span></span><br><span class="line">*pb=<span class="number">20</span>;   b=<span class="number">20</span>； <span class="comment">//错误，b为const变量，皆不可修改</span></span><br></pre></td></tr></table></figure><ul><li><strong>常指针</strong></li></ul><p>定义形式：<code>typename *const varname</code></p><p><strong>类型为指针</strong></p><p><strong>指针变量的指向<code>不能改变</code><strong>。</strong>但是其指向的变量的值可改变</strong></p><p><strong><code>必须在定义时初始化</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">4</span> ,  b=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>  *<span class="keyword">const</span> p=&amp;a ;   <span class="comment">//定义常量指针，指向变量a</span></span><br><span class="line">*p=<span class="number">5</span>;<span class="comment">//正确，p指向a，变量a的值改为5</span></span><br><span class="line">p=&amp;b;<span class="comment">//错误，p为常量指针，不能改变其指向</span></span><br></pre></td></tr></table></figure><ul><li><strong>指向常量的常指针</strong></li></ul><p>定义形式：<code> const  typename *const varname</code></p><p><strong>是一个指针</strong></p><p><strong>不能改变其指向，也不能通过指针运算符改变指针所指向的变量的值。</strong><code>但可以直接改变变量的值</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">4</span> ,  b=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  *<span class="keyword">const</span> pt=&amp;a ;   <span class="comment">//定义常量指针，指向变量a</span></span><br><span class="line">*pt=<span class="number">5</span>;<span class="comment">//错误，不能通过指针运算符改变变量的值</span></span><br><span class="line">pt=&amp;b;<span class="comment">//错误，p为常量指针，不能改变其指向</span></span><br><span class="line">a=<span class="number">5</span>;<span class="comment">//正确，可以直接改变变量的值。若是定义为const a=4,则a=5也是错误的。</span></span><br></pre></td></tr></table></figure><h3 id="8-void指针类型"><a href="#8-void指针类型" class="headerlink" title="8. void指针类型"></a>8. <strong>void指针类型</strong></h3><p>**格式：<code>void *pt</code>**，不指向确定类型的指针。</p><p><strong>void</strong> 类型的指针变量可以存储任何类型的指针，但是不能判断出指向对象的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  *p=&amp;a； <span class="keyword">void</span> *vp=p;<span class="comment">//合法，但是只获得变量的地址，而没有获得长度</span></span><br></pre></td></tr></table></figure><p><strong>void</strong>指针赋值给其他类型的指针时都要进行类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type *vp = (type*)vp; <span class="comment">//转换类型也就是获得指向变量/对象大小</span></span><br></pre></td></tr></table></figure><p><strong>void</strong>指针不能参与指针运算,除非进行转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(type*)vp++; <span class="comment">//vp=vp+sizeof(type)</span></span><br></pre></td></tr></table></figure><p><strong>Example</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *q=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">void</span> *p=&amp;x;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;*p=&quot;&lt;&lt;*p&lt;&lt;endl;//错误，非法使用指针p</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*p=&quot;</span>&lt;&lt;*(<span class="keyword">char</span>*)p&lt;&lt;endl;<span class="comment">//正确，输出指针p所指向单元的内容</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*p=&quot;</span>&lt;&lt;*(<span class="keyword">int</span>*)p&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*p=&quot;</span>&lt;&lt;*(<span class="keyword">float</span>*)p&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*p=&quot;</span>&lt;&lt;*(<span class="keyword">double</span>*)p&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//q=p;//错误，非法赋值，将void指针赋值给整型指针</span></span><br><span class="line">    q=(<span class="keyword">int</span>*)p;<span class="comment">//正确，赋值时进行强制类型转换为int*型</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*q=&quot;</span>&lt;&lt;*q&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-引用"><a href="#9-引用" class="headerlink" title="9. 引用"></a>9. <strong>引用</strong></h3><p>格式： 类型  &amp;引用名= 变量名 。<code>&amp;</code>为引用声明符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp;d=c;<span class="comment">//&amp;是引用的声明符</span></span><br><span class="line"><span class="keyword">int</span> *pt=&amp;a;<span class="comment">//&amp;是取地址运算符</span></span><br></pre></td></tr></table></figure><ul><li>引用的类型必须和其所绑定的变量的类型相同</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a=<span class="number">10.3</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;b=a; <span class="comment">//错误，引用的类型必须和其所绑定的变量的类型相同</span></span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明一个引用时，必须同时初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;a; <span class="comment">//错误！声明引用的同时必须对其初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以取引用的地址，实质上就是取引用的变量的地址</li></ul><p><a href="https://www.cnblogs.com/duwenxing/p/7421100.html">C++：引用的简单理解</a></p><h3 id="10-结构体类型"><a href="#10-结构体类型" class="headerlink" title="10. 结构体类型"></a>10. <strong>结构体类型</strong></h3><p><strong>C++中结构体和类的区别</strong></p><ul><li><p><strong>结构体和类具有不同的默认访问属性。类中，对于未指定访问属性的成员，其访问属性为private，结构体中为public。</strong></p></li><li><p><strong>struct默认为public继承，class默认为private继承</strong></p></li></ul><p>实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span>　</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>　　<span class="comment">//定义结构体　　</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;　</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>　</span></span><br><span class="line"><span class="class">&#123;</span>　　</span><br><span class="line">    <span class="comment">//包含两个变量成员　</span></span><br><span class="line">    <span class="keyword">int</span> x;　　</span><br><span class="line">    <span class="keyword">int</span> y;　</span><br><span class="line">&#125;;　　</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span>　</span></span><br><span class="line"><span class="function"></span>&#123;　　</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt</span>;</span>　</span><br><span class="line">    pt.x=<span class="number">1</span>;　</span><br><span class="line">    pt.y=<span class="number">2</span>;　</span><br><span class="line">    cout&lt;&lt;pt.x&lt;&lt;endl&lt;&lt;pt.y&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-new和delete运算符"><a href="#11-new和delete运算符" class="headerlink" title="11. new和delete运算符"></a>11. <strong>new和delete运算符</strong></h3><p><code>new</code>运算符：动态分配存储空间。</p><p>格式：new <strong>类型</strong> [初值]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">//开辟了一个存放整数的存储空间，返回其指针</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">100</span>); <span class="comment">//指定该整数的初值为100，并返回指针</span></span><br><span class="line"><span class="keyword">char</span> *pt=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; <span class="comment">//开辟一个存放字符数组(10个元素)的空间，返回字符数组首地址。</span></span><br><span class="line"><span class="keyword">float</span> *p=<span class="keyword">new</span> <span class="built_in"><span class="keyword">float</span></span>(<span class="number">3.1415</span>); <span class="comment">//开辟一个存放float的控件，其初值为3.1415，并返回其地址给指针变量p。</span></span><br></pre></td></tr></table></figure><p><strong>delete</strong>运算符：撤销上面<code>new</code>开辟的存储空间</p><p>格式：delete 指针变量/delete [] 指针变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;<span class="comment">//删除p指向的存储空间</span></span><br><span class="line"><span class="keyword">delete</span> [] pt; <span class="comment">//删除pt指向的动态数组</span></span><br></pre></td></tr></table></figure><p><strong>实验五ex1中</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义Array类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:    <span class="comment">//指针指向new空间，len为初始化数组长度</span></span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="keyword">int</span> b[],<span class="keyword">int</span> length)&#123;  <span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        len=length;     <span class="comment">//初始化数组长度</span></span><br><span class="line">        a=<span class="keyword">new</span> <span class="keyword">int</span>[length];  <span class="comment">//动态创建一个与实参长度一样的数组</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)&#123;  <span class="comment">//给新创建的数组赋值</span></span><br><span class="line">            a[i]=b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Array</span>()&#123;   <span class="comment">//析构函数，删除动态创建的数组</span></span><br><span class="line">        <span class="keyword">delete</span> [] a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="12-枚举类型"><a href="#12-枚举类型" class="headerlink" title="12. 枚举类型"></a>12. <strong>枚举类型</strong></h3><p>格式：enum 枚举类型名 [枚举常量表]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个枚举类型,&#123;&#125;中的为枚举元素/枚举常量</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">weekday</span>&#123;</span>sun,mon,tue,thu,fri,sat&#125;;</span><br><span class="line">weekday workday;</span><br><span class="line">workday=mon;  <span class="comment">//枚举变量的值只能是枚举常量之一</span></span><br></pre></td></tr></table></figure><p>枚举元素为常量，其值是一个整数，编译系统按照定义时的顺序将他们赋值为0,1,2……，所以枚举值可以按照整数比较规则进行判断比较。</p><p><strong>不能将一个整数直接赋给枚举变量，枚举变量只能接受枚举类型数据。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workday=tue;  <span class="comment">//正确，将枚举常量赋值给枚举变量</span></span><br><span class="line">workday=<span class="number">2</span>;<span class="comment">//错误，它们是不同的类型。</span></span><br></pre></td></tr></table></figure><h3 id="文档——指针和引用"><a href="#文档——指针和引用" class="headerlink" title="文档——指针和引用"></a><strong>文档——指针和引用</strong></h3><p><strong>指针变量</strong></p><p>指针是一种类型，此类型变量中存放的是另一个变量/对象的地址。</p><p>指针变量是一个实体，即在内存中实实在在的存在。指针变量本身具备变量的4个属性：变量名、变量值、变量地址、变量类型。它的<code>值就是另一个变量的地址</code>。它的<code>类型就是指针类型</code>。</p><p>通过基类型确定指向变量/对象所占据的内存大小，所以void类型的指针为空指针，表示此变量仅仅存放一个地址，没有指向对象所占内存的信息，所以void指针是无法通过指针运算符来取值的。</p><p><strong>引用</strong></p><p>而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。由于它不是一个专门的变量，所以不分配内存空间。</p><p> **它们之间的区别(下面的指针皆为指针变量的简称)**：</p><ul><li><p>指针是一个实体，而引用仅是个别名；</p></li><li><p>引用必须被初始化，指针不必；</p></li><li><p>引用只能在定义时被初始化一次，之后不可变；指针可以改变所指的对象；</p></li></ul><ul><li><p>不存在指向空值的引用，但是存在指向空值的指针，即引用不能为空，指针可以为空；</p></li><li><p>“sizeof 引用”得到的是所指向的变量（对象）的大小，而“sizeof 指针”得到的是指针本身的大小；</p></li><li><p>程序为指针变量分配内存区域，而引用不需要分配内存区域；</p></li><li><p>指针可以有多级，但是引用只能是一级，例如<code>int **p</code>是合法的，而<code> int &amp;&amp;a</code>是不合法的；<br>更多详细参阅<a href="">第1-7章-指针和引用.docx</a></p></li></ul><h1 id="第8章-类和对象的特性"><a href="#第8章-类和对象的特性" class="headerlink" title="第8章-类和对象的特性"></a>第8章-类和对象的特性</h1><h3 id="1-面向对象程序设计方法概述"><a href="#1-面向对象程序设计方法概述" class="headerlink" title="1. 面向对象程序设计方法概述"></a>1. <strong>面向对象程序设计方法概述</strong></h3><p> <strong>面向对象程序设计的4个主要特点</strong>：<strong>“抽象”、“封装”、“继承”、“多态”</strong></p><p><strong>C++中对象的构成：数据和函数</strong></p><ul><li>数据即对象的属性</li><li>函数：对数据进行操作，以便实现某些功能，即行为。在程序设计中称为：方法。</li></ul><h3 id="2-类的声明和对象的定义"><a href="#2-类的声明和对象的定义" class="headerlink" title="2. 类的声明和对象的定义"></a>2. <strong>类的声明和对象的定义</strong></h3><p><strong>声明中未指定访问限定符的成员，系统默认为私有。</strong></p><p>private和public可以出现多次。有效范围为开始到另一个访问限定符或类体结束时为止。</p><p><strong>定义对象的3种方法（类似结构体）</strong></p><p>方法1：先声明类类型，然后再定义对象，有两种形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>） <span class="class"><span class="keyword">class</span> 类名 对象名，例如 <span class="keyword">class</span> <span class="title">Student</span>  <span class="title">stud1</span>;</span> </span><br><span class="line">（<span class="number">2</span>） 类名 对象名 ，例如 Student  stud1，stud2;</span><br></pre></td></tr></table></figure><p>方法2：在声明类时定义对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span>  <span class="comment">//声明类</span></span><br><span class="line">……           </span><br><span class="line">&#125;stud1，stud2;</span><br></pre></td></tr></table></figure><p>方法3：不出现类名，直接定义对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &#123;</span><span class="comment">//无类名</span></span><br><span class="line">…                        </span><br><span class="line">&#125;stud1，stud2;<span class="comment">//定义了两个无类名的类对象</span></span><br></pre></td></tr></table></figure><h3 id="3-类的成员函数"><a href="#3-类的成员函数" class="headerlink" title="3. 类的成员函数"></a>3. <strong>类的成员函数</strong></h3><p>成员函数在<code>类内声明，类外定义</code>。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">( )</span></span>;<span class="comment">//公用成员函数的函数原型</span></span><br><span class="line">……</span><br><span class="line">&#125;;<span class="comment">//类定义结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类外定义display类函数，必须在函数名前面加上类名，予以限定。</span></span><br><span class="line"><span class="keyword">void</span> Student∷<span class="built_in">display</span>( ) &#123;<span class="comment">//“::” 作用域限定符</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义类外函数，若“∷”前面没有类名，或函数名前面无类名无“∷”，则函数为全局函数。如<code> ∷display( )</code>或<code>display( ) </code>。</p><p><strong>inline成员函数</strong></p><p>如果在类体中定义的成员函数中不包括循环等控制结构，C++系统会自动将它们作为内置(inline)函数来处理。所以类内定义的成员函数一般省略inline。</p><p>如果成员函数在类体外定义，系统并不把它默认为内置(inline)函数，如果想将这些成员函数指定为内置函数，需用inline作显式声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例：类体外定义<span class="keyword">inline</span>函数</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">( )</span></span>; <span class="comment">//声明此成员函数为内置函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> <span class="keyword">inline</span> <span class="keyword">void</span> Student∷<span class="built_in">display</span>( ) &#123;<span class="comment">// 在类外定义display函数为内置函数</span></span><br><span class="line">…… <span class="comment">// 函数的定义与类定义必须在同一个文件内</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>**如果在类体外定义inline函数，则必须将类定义和成员函数的定义都放在同一个头文件中(或者写在同一个源文件中)**。</p><p>上文中有[函数/类模板的声明和实现必须放在一个文件里](#4. 函数模板)</p><h3 id="4-对象成员的引用"><a href="#4-对象成员的引用" class="headerlink" title="4. 对象成员的引用"></a>4. <strong>对象成员的引用</strong></h3><p>访问对象中的成员的3种方法：</p><ul><li>通过对象名和成员运算符     格式：对象名.成员名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stud1.num=<span class="number">1001</span>; <span class="comment">//num为公用的整型数据成员</span></span><br></pre></td></tr></table></figure><ul><li>通过指向对象的指针       格式：指针-&gt;成员名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;hour;  <span class="comment">//输出p指向的对象中的成员hour</span></span><br></pre></td></tr></table></figure><ul><li>通过对象的引用变量      格式：别名.成员名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Time t1;        <span class="comment">//定义对象t1</span></span><br><span class="line">Time &amp;t2=t1;  <span class="comment">//定义Time类引用变量t2</span></span><br><span class="line">cout&lt;&lt;t2.hour;   <span class="comment">//输出对象t1中的成员hour</span></span><br></pre></td></tr></table></figure><h3 id="5-几个名词解释"><a href="#5-几个名词解释" class="headerlink" title="5. 几个名词解释"></a>5. <strong>几个名词解释</strong></h3><p>方法：类的成员函数在面向对象程序理论中被称为“方法”(method)，“方法”是指对数据的操作。一个“方法”对应一种操作</p><p>消息：所谓“消息”，其实就是一个命令，由程序语句来实现。例如：stud.display( );就是向对象stud对象发出的一个“消息”，通知它执行其中的display“方法”。</p><p><strong>stud.display( )语句中，stud是对象，display()是方法，语句“stud.display( );”是消息。</strong></p><h1 id="第9章-怎样使用类和对象"><a href="#第9章-怎样使用类和对象" class="headerlink" title="第9章-怎样使用类和对象"></a>第9章-怎样使用类和对象</h1><h3 id="1-利用构造函数对数据成员的初始化"><a href="#1-利用构造函数对数据成员的初始化" class="headerlink" title="1. 利用构造函数对数据成员的初始化"></a>1. <strong>利用构造函数对数据成员的初始化</strong></h3><ul><li><p><strong>无参(默认)构造函数</strong>（在建立对象时不需要实参）</p><ol><li><p>如果类中未自定义构造函数，系统会<code>自动</code>生成一个<code>无参无函数体</code>的默认构造函数(数据成员值随机)。注意：一旦类中有其他自定义构造函数，此函数将不会再自动生成</p></li><li><p>自定义的无参构造函数</p></li><li><p>自定义的全部参数带默认值的构造函数</p></li></ol></li></ul><p>注：每个类<code>只能有一个</code>默认构造函数，不然系统无法确定调用的是哪一个默认构造函数。</p><p>例：假设A为已定义的类，此类有默认构造函数A()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A test; <span class="comment">//定义对象test，自动调用默认的构造函数A()</span></span><br></pre></td></tr></table></figure><p><strong>构造函数不需要用户调用，且不能通过函数调用的方式来调用。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A mya;<span class="comment">//A为已定义类,自动调用构造函数创建对象</span></span><br><span class="line">mya.<span class="built_in">A</span>();<span class="comment">//错误，对象不能调用构造函数</span></span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">()</span></span>;<span class="comment">//新建对象的错误格式，此为函数原型</span></span><br></pre></td></tr></table></figure><p><strong>构造函数除了创建对象时自动调用，还可以怎么调用？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A mya; </span><br><span class="line">mya=<span class="built_in">A</span>(); <span class="comment">//新建一个匿名的临时对象，调用构造函数A()完成临时对象的初始化，并将临时对象赋值给mya对象，匿名对象在语句结束后即被析构。</span></span><br></pre></td></tr></table></figure><ul><li><strong>带参数的构造函数</strong></li></ul><p>带参数的构造函数首部的一般格式为<code>构造函数名(类型 1 形参1，类型2 形参2，…)</code></p><p>实参是在定义对象时给出的。定义对象的一般格式为 <code>类名 对象名(实参1，实参2，…);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span><span class="comment">//声明长方柱Box类</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>);  <span class="comment">//声明带参数的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">()</span></span>;     <span class="comment">//声明计算体积的函数</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在类外定义带参数的构造函数</span></span><br><span class="line">Box∷<span class="built_in">Box</span>(<span class="keyword">int</span> h,<span class="keyword">int</span> w,<span class="keyword">int</span> len) &#123;</span><br><span class="line">    height=h;</span><br><span class="line">    width=w;</span><br><span class="line">    length=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义计算体积的函数</span></span><br><span class="line"><span class="keyword">int</span> Box∷<span class="built_in">volume</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span>( height*width*length );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立对象box1，并指定box1长、宽、高的值</span></span><br><span class="line">    <span class="function">Box <span class="title">box1</span><span class="params">(<span class="number">12</span>,<span class="number">25</span>,<span class="number">30</span>)</span></span>; </span><br><span class="line">    cout&lt;&lt;″box1：″&lt;&lt;box1.<span class="built_in">volume</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//建立对象box2，并指定box2长、宽、高的值</span></span><br><span class="line">    <span class="function">Box <span class="title">box2</span><span class="params">(<span class="number">15</span>,<span class="number">30</span>,<span class="number">21</span>)</span></span>;           </span><br><span class="line">    cout&lt;&lt;″box2：″&lt;&lt;box2.<span class="built_in">volume</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>用参数初始化表对数据成员初始化</strong></li></ul><p>不在函数体内对数据成员初始化，而是在函数首部实现</p><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类名::构造函数名([参数表])[:成员初始化表] &#123;</span><br><span class="line">[构造函数体]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如例<span class="number">9.2</span>中定义构造函数可以改用以下形式： </span><br><span class="line">Box∷<span class="built_in">Box</span>(<span class="keyword">int</span> h,<span class="keyword">int</span> w,<span class="keyword">int</span> len):<span class="built_in">height</span>(h)，<span class="built_in">width</span>(w)，<span class="built_in">length</span>(len)&#123;……&#125;</span><br><span class="line">用形参h/w/len的值初始化成员数据height ……</span><br></pre></td></tr></table></figure><p><strong>注意：如果数据成员是<code>数组</code>，则应当在构造函数的函数体中用语句对其赋值，而<code>不能</code>在参数初始化表对其初始化。</strong></p><ul><li><strong>构造函数的重载</strong></li></ul><p>一个类中可以定义多个构造函数。这些构造函数具有相同的名字,而参数的个数或参数的类型不相同</p><p><strong>构造函数的重载使用说明：</strong></p><p><del>调用构造函数时不必给出实参的构造函数，称为默认构造函数。</del>一个类<code>只能有一个</code>默认构造函数。</p><p>在一个类中可以包含多个构造函数，但建立对象时只执行其中一个构造函数，并非每个构造函数都被执行。</p><ul><li><strong>使用默认参数的构造函数</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">//在声明构造函数时指定默认参数</span></span><br><span class="line">        <span class="built_in">Box</span>(<span class="keyword">int</span> h=<span class="number">10</span>,<span class="keyword">int</span> w=<span class="number">10</span>,<span class="keyword">int</span> len=<span class="number">10</span>);</span><br><span class="line">    ……</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//在定义函数时可以不指定默认参数</span></span><br><span class="line">Box∷<span class="built_in">Box</span>(<span class="keyword">int</span> h,<span class="keyword">int</span> w,<span class="keyword">int</span> len) &#123;</span><br><span class="line">    height=h;</span><br><span class="line">    width=w;</span><br><span class="line">    length=len;</span><br><span class="line">&#125;        </span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    Box box1;              <span class="comment">//没有给实参 </span></span><br><span class="line">    cout&lt;&lt;″box1:″&lt;&lt;box1.<span class="built_in">volume</span>( )&lt;&lt;endl;</span><br><span class="line">    <span class="function">Box <span class="title">box2</span><span class="params">(<span class="number">15</span>)</span></span>;       <span class="comment">//只给定一个实参</span></span><br><span class="line">    cout&lt;&lt;″box2:″&lt;&lt;box2.<span class="built_in">volume</span>( )&lt;&lt;endl;</span><br><span class="line">    <span class="function">Box <span class="title">box3</span><span class="params">(<span class="number">15</span>,<span class="number">30</span>)</span></span>;  <span class="comment">//只给定2个实参</span></span><br><span class="line">    cout&lt;&lt;″box3:″&lt;&lt;box3.<span class="built_in">volume</span>( )&lt;&lt;endl;</span><br><span class="line">    <span class="function">Box <span class="title">box4</span><span class="params">(<span class="number">15</span>,<span class="number">30</span>,<span class="number">20</span>)</span></span>;  <span class="comment">//给定3个实参</span></span><br><span class="line">    cout&lt;&lt;″box4:″&lt;&lt;box4.<span class="built_in">volume</span>( )&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li><p>应在<code>声明</code>构造函数时指定默认值，而<code>不能只在</code>定义构造函数时指定默认值。</p></li><li><p>在声明构造函数时，形参名可以省略。例如    Box(int=10, int=10, int=10);</p></li><li><p><strong>由于不需要实参也可以调用构造函数，因此全部参数都指定了默认值的构造函数也属于默认构造函数。但一个类只能有一个默认构造函数。</strong></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Box</span>();</span><br><span class="line"><span class="built_in">Box</span>(<span class="keyword">int</span>=<span class="number">10</span>, <span class="keyword">int</span>=<span class="number">10</span>, <span class="keyword">int</span>=<span class="number">10</span>);</span><br><span class="line">Box b1； <span class="comment">//错误，不能确定调用的是哪个构造函数</span></span><br></pre></td></tr></table></figure><ol start="4"><li>类中定义了全部都是默认参数的构造函数后，不能再定义重载构造函数（默认参数函数与重载函数会产生冲突） </li></ol></blockquote><h3 id="2-析构函数"><a href="#2-析构函数" class="headerlink" title="2. 析构函数"></a>2. <strong>析构函数</strong></h3><p>函数名：类名的前面加一个“～”符号</p><p>执行析构函数的几种情况:</p><ul><li><input checked="" disabled="" type="checkbox"> 函数中定义的对象(自动局部对象)，此函数结束，对象会被释放，在对象释放前自动执行析构函数。</li><li><input checked="" disabled="" type="checkbox"> static局部对象和全局对象在程序结束时，调用该对象的析构函数。</li><li><input checked="" disabled="" type="checkbox"> new运算符动态创建的对象，用delete运算符释放该对象时，先调用该对象的析构函数。</li></ul><p>注意:</p><ul><li><strong>析构函数<code>不返回任何值</code>，<code>没有函数类型</code>，也<code>没有函数参数</code>。因此它<code>不能被重载</code>。</strong></li><li><strong>一个类可以有多个构造函数，但只能有一个析构函数。</strong></li><li>如果没有定义析构函数，C++编译系统会自动生成一个析构函数，但没有任何操作。</li><li>销毁对象只删除回收此对象的成员函数、成员变量以及其他这个对象所占有的内存；而它所管理或者有依赖关系的一些资源不会自动销毁，需要在<code>析构函数</code>中销毁，否则会成为存在却不会被使用的资源。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：定义类A, 在类中定义一个指针类型的成员变量：</span><br><span class="line"><span class="keyword">char</span> * pa; </span><br><span class="line">定义A的对象 A a，使用pa去<span class="keyword">new</span>一块内存进行引用。</span><br><span class="line">a.pa = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]；</span><br></pre></td></tr></table></figure><p>释放a的内存的时候，系统只会自动收回指针对象pa所占的内存空间。而new出来的内存不是对象的成员，不会被回收。</p><h3 id="3-调用构造函数和析构函数的顺序"><a href="#3-调用构造函数和析构函数的顺序" class="headerlink" title="3. 调用构造函数和析构函数的顺序"></a>3. <strong>调用构造函数和析构函数的顺序</strong></h3><p><code>一般情况下</code>，程序中调用析构函数的次序与调用构造函数的次序相反： 最先被调用的构造函数(最先建立的对象)，其对应的析构函数最后调用，而最后被调用的构造函数，其对应的析构函数最先被调用。</p><h3 id="4-对象数组"><a href="#4-对象数组" class="headerlink" title="4. 对象数组"></a>4. <strong>对象数组</strong></h3><ol><li>若构造函数<code>只有一个参数</code>，定义数组时可以直接提供实参，实现对象的初始化。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stu[<span class="number">2</span>]=&#123;<span class="number">60</span>,<span class="number">70</span>&#125;; <span class="comment">//实参传给2个数组元素的构造函数</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>若构造函数有<code>多个参数</code>，初始化方法为：在花括号中分别写出构造函数并指定实参。</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：如果构造函数有<span class="number">3</span>个参数，分别代表学号、年龄、成绩： </span><br><span class="line">Student Stud[<span class="number">2</span>]=&#123;<span class="comment">//定义对象数组</span></span><br><span class="line">  <span class="built_in">Student</span>(<span class="number">1001</span>,<span class="number">18</span>,<span class="number">87</span>),  <span class="comment">//调用第1个元素的构造函数</span></span><br><span class="line">  <span class="built_in">Student</span>(<span class="number">1002</span>,<span class="number">19</span>,<span class="number">76</span>),  <span class="comment">//调用第2个元素的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-对象指针"><a href="#5-对象指针" class="headerlink" title="5. 对象指针"></a>5. <strong>对象指针</strong></h3><p>编译系统会为对象分配存储空间存放其成员。对象存储空间的起始地址即对象的地址,可以定义一个指针变量，用来存放对象的指针，此指针变量即为对象指针。</p><p><strong>定义形式为 ：类名 * 对象指针名；</strong></p><p>例如：定义指向对象的指针变量并通过对象指针访问对象和对象成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span>    <span class="comment">//定义Time类和定义Time对象t1；</span></span><br><span class="line">……</span><br><span class="line">&#125;t1;</span><br><span class="line">Time * pt=&amp;t1;  <span class="comment">//定义pt为指向Time类对象的指针变量并初始化</span></span><br><span class="line">*pt              <span class="comment">//表示pt所指向的对象，即t1。</span></span><br><span class="line">(*pt).hour       <span class="comment">//pt所指向的对象中的hour成员，即t1.hour</span></span><br><span class="line">pt-&gt;hour         <span class="comment">//pt所指向的对象中的hour成员，即t1.hour</span></span><br><span class="line">(*pt).<span class="built_in">get_time</span>()<span class="comment">//即t1.get_time</span></span><br><span class="line">pt-&gt;<span class="built_in">get_time</span>()  <span class="comment">// 总结：(*pname).xx/pname-&gt;xx ，均可</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>指向对象<code>数据成员</code>的指针变量</strong></li></ul><blockquote><p><code>数据类型名 *指针变量名</code>；//与普通的指针变量一样</p></blockquote><p>​    例：Time类的数据成员hour为public，在类外通过指向对象数据成员的指针变量访问（较少使用）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1; <span class="comment">//定义指向整型数据的指针变量</span></span><br><span class="line">p1=&amp;t1.hour; <span class="comment">//p1指向t1.hour</span></span><br><span class="line">cout&lt;&lt;*p1&lt;&lt;endl; <span class="comment">//输出t1.hour的值</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>指向对象<code>成员函数</code>的指针</strong></li></ul><p><strong>指针变量的类型必须与成员函数的类型相匹配：</strong></p><ol><li><strong>函数参数的类型和参数个数</strong></li><li><strong>函数返回值的类型</strong></li><li><strong><code>所属的类</code></strong></li></ol><blockquote><p><strong>定义：数据类型名(<code>类名</code>∷指针变量名)(参数表列);</strong></p><p><strong>初始化：指针变量名=<code>&amp;</code>类名::成员函数名;</strong></p></blockquote><p>例：定义指针p2指向Time类中公用成员函数get_time</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">void</span></span> (Time∷*p2)( ) = &amp;Time∷get_time; </span><br></pre></td></tr></table></figure><hr><ul><li><strong>this</strong> <strong>指针</strong></li></ul><p>在每个<code>成员函数</code>中都包含一个名为<code>this</code>的指针变量(隐式参数)。它是指向<code>本类对象的指针</code>，它的值是当前被调用的成员函数所在的对象的地址。所以，<code>*this</code> 即本对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">成员函数volume的定义如下： </span><br><span class="line"><span class="keyword">int</span> Box∷<span class="built_in">volume</span>( ) &#123;</span><br><span class="line">      <span class="keyword">return</span> (height*width*length);      </span><br><span class="line">&#125;</span><br><span class="line">C++把它处理为：</span><br><span class="line"><span class="keyword">int</span> Box∷<span class="built_in">volume</span>(Box *<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>(<span class="keyword">this</span>-&gt;height * <span class="keyword">this</span>-&gt;width *…);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：this指针是隐式使用的，是编译系统自动实现的，在需要时也可以显式地使用this指针。</p><h3 id="6-共用数据的保护"><a href="#6-共用数据的保护" class="headerlink" title="6. 共用数据的保护"></a>6. <strong>共用数据的保护</strong></h3><ul><li><strong>常对象</strong>：对象数据成员的值不能改变。注意，常对象<code>必须要有初值</code>。定义格式：</li></ul><p> <strong>类名 const 对象名[(实参表列)];</strong> 或 <strong>const 类名 对象名[(实参表列)];</strong></p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Time <span class="keyword">const</span> <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>)</span></span>;  <span class="comment">//成员数据必须要赋初值。</span></span><br></pre></td></tr></table></figure><ul><li><p><input checked="" disabled="" type="checkbox">  常对象的成员数据都是const类型（定义对象时，将对象的数据成员自动设置成了const成员）。</p></li><li><p><input checked="" disabled="" type="checkbox">  注意：常对象中的成员函数<code>不会</code>被自动设置为常成员函数。常对象只保证其数据成员是常数据成员。</p></li><li><p><input checked="" disabled="" type="checkbox">  常对象<code>只能调用其const函数</code>。const函数可以访问该对象的数据成员，但不允许修改常对象中数据成员的值(只读)。</p></li><li><p><strong>常数据成员</strong>：对象的数据成员为const数据，在<code>类定义阶段</code>声明。</p></li></ul><div class="note warning modern"><p>注意：<code>只能</code>通过构造函数的<code>参数初始化表</code>对常数据成员进行初始化</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//Time()&#123;&#125; ,报错</span></span><br><span class="line">    <span class="built_in">Time</span> (<span class="keyword">int</span> a):<span class="built_in">hour</span>(a)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> hour;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//若类定义中有默认构造函数，程序会报错，因为const数据成员必须通过参数初始化表来初始化</span></span><br></pre></td></tr></table></figure><p>常对象的数据成员都是const数据，那常对象的构造函数**<code>只能用参数初始化表对const数据成员进行初始化</code>**</p><p>(这句话是对的),但是，//定义类时，不确定此类是否会定义常对象，不会特意定义参数初始化表。所以定义常对象时，不用参数初始化表也可以建立常对象。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//定义const函数，用以访问const数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test::show</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">Test::<span class="built_in">Test</span>(<span class="keyword">int</span> sa)&#123;</span><br><span class="line">    a=sa;<span class="comment">//没用参数初始化表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Test <span class="title">t2</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">show</span>();</span><br><span class="line">    t2.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意，常对象只能调用const函数，所以show函数不定义为const，程序会报错。</span></span><br></pre></td></tr></table></figure><div class="note default modern"><p>原来<code>参数初始化列表</code>和<code>参数的构造函数</code>不是一回事😂</p></div><ul><li><strong>常成员函数</strong>：只能读取数据成员，不能修改。定义格式：类型名 函数名(参数表) <code>const</code>；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：<span class="function"><span class="keyword">void</span> <span class="title">get_time</span><span class="params">( )</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><p>const修饰符在<code>声明函数</code>和<code>定义函数</code>时都要有const关键字，在调用时不必加const。</p><p>常成员函数可以引用const数据成员可以被const和非const成员函数引用，但不能修改它。</p><p>const数据成员可以被const和非const成员函数引用，但不能修改它。</p><p><strong>注意：类中的常成员函数<code>不能</code>调用另一个非const成员函数，即只能调用const成员函数。</strong></p><p><strong>表9.1</strong></p><table><thead><tr><th>数据成员</th><th>非const的普通成员函数</th><th>const成员函数</th></tr></thead><tbody><tr><td>非const的普通数据成员</td><td>可以引用，也可以改变值</td><td>可以引用，但不可以改变值</td></tr><tr><td>const数据成员</td><td>可以引用，但不可以改变值</td><td>可以引用，但不可以改变值</td></tr><tr><td>const对象</td><td>不允许</td><td>可以引用，但不可以改变值</td></tr></tbody></table><h3 id="7-指向对象的常指针"><a href="#7-指向对象的常指针" class="headerlink" title="7. 指向对象的常指针"></a>7. <strong>指向对象的常指针</strong></h3><p>将指针变量声明为const型，这样<code>指针值始终保持为其初值</code>，不能改变。例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Time t1(10,12,15), t2; //定义Time对象</span><br><span class="line"><span class="comment">//const位置在指针变量名前面，规定ptr1的值是常值</span></span><br><span class="line">Time * <span class="keyword">const</span> ptr1; </span><br><span class="line">ptr1=&amp;t1; <span class="comment">//ptr1指向对象t1，此后不能再改变指向</span></span><br><span class="line">ptr1=&amp;t2; <span class="comment">//错误，ptr1不能改变指向</span></span><br></pre></td></tr></table></figure><p>定义形式：<strong>类名 *</strong> <strong>const</strong> <strong>指针变量名；</strong></p><p>也可在定义时初始化，如将上面3，4行合并为：<code>Time * const ptr1=&amp;t1</code>; </p><p>注意：</p><ol><li>指向不能变，但可以改变所指对象的值</li><li>指向<code>变量</code>的const指针<a href="#7.const%E6%8C%87%E9%92%88">必须在定义时初始化</a>(P178)，而指向<code>对象</code>的指针定义时可以不立即初始化，但是一旦赋值，后面就不能再次赋值。</li></ol><h3 id="8-指向常对象的指针变量"><a href="#8-指向常对象的指针变量" class="headerlink" title="8. 指向常对象的指针变量"></a>8. <strong>指向常对象的指针变量</strong></h3><p>定义形式：const 类型名 * 指针变量名；</p><p>表示不能<code>通过此指针变量</code>来改变此常对象值。</p><p>注意：</p><ol><li>常对象只能用指向常对象的指针变量指向它，而不能用一般的(指向非const型变量的)指针变量去指向它（防止通过指针改变其值）。</li><li>指向常对象的指针变量可以改变其指向的对象。</li><li>指向常对象的指针变量除了可以指向常对象外，还可以指向非const对象，但此时不能通过此指针变量改变该对象的值（此非const对象可以通过对象本身改变）</li><li>指向常对象的指针最常用于函数的形参，如果函数的形参是指向<code>非const型</code>对象的指针，实参只能用指向非const对象的指针(在函数中需要改变参数值)。如果函数的形参是指向const型对象的指针，实参可以是指向const对象的指针，或指向非const对象的指针。对应关系见教材的表9.2。</li></ol><p><strong>对前面<a href="#const%E6%8C%87%E9%92%88">指向常变量的指针变量</a>的进一步讨论</strong></p><p><strong>说明</strong>：</p><ol><li><strong>如果一个变量已被声明为常变量，只能用指向常变量的指针变量指向它</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> c[]=<span class="string">&quot;boy&quot;</span>;<span class="comment">//定义const型的char数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1;<span class="comment">//定义p1为指向const型的char变量的指针变量</span></span><br><span class="line">p1=c;<span class="comment">//合法，p1指向常变量</span></span><br><span class="line"><span class="keyword">char</span> *p2=c;<span class="comment">//不合法，p2不是指向常变量的指针变量</span></span><br></pre></td></tr></table></figure><ol start="2"><li>指向常变量的指针变量除了可以指向常变量外，还可以指向未被声明为const的。此时不能通过此指针改变该变量的值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1=<span class="string">&#x27;a&#x27;</span>;<span class="comment">//定义字符变量，它未被声明为const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1;<span class="comment">//定义了一个指向常变量的指针变量p</span></span><br><span class="line">p1=&amp;c1;<span class="comment">//使p指向字符变量c1</span></span><br><span class="line">*p=<span class="string">&#x27;b&#x27;</span>;<span class="comment">//非法，不能通过p改变变量c1的值</span></span><br><span class="line">c1=<span class="string">&#x27;b&#x27;</span>;<span class="comment">//合法，没有通过p访问c1，c1不是常变量</span></span><br></pre></td></tr></table></figure><p><strong>表9.2</strong></p><table><thead><tr><th>形参</th><th>实参</th><th>合法否</th><th>改变指针所指向的变量的值</th></tr></thead><tbody><tr><td>指向非const型变量的指针</td><td>非const变量的地址</td><td>合法</td><td>可以</td></tr><tr><td>指向非const型变量的指针</td><td>const变量的地址</td><td>非法</td><td>/</td></tr><tr><td>指向const型变量的指针</td><td>const变量的地址</td><td>合法</td><td>不可以</td></tr><tr><td>指向const型变量的指针</td><td>非const变量的地址</td><td>合法</td><td>不可以</td></tr></tbody></table><h3 id="9-对象的常引用"><a href="#9-对象的常引用" class="headerlink" title="9. 对象的常引用"></a>9. <strong>对象的常引用</strong></h3><p>形参为对象的引用，实参为对象名，则在调用函数进行虚实结合时，并不是为形参另外开辟一个存储空间，而是把实参对象的地址传给形参(引用名)，这样引用名也指向实参对象。         </p><p>如果不希望在函数中修改实参的值，可以把引用对象声明为const(常引用)。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> Time &amp;t)</span></span>;</span><br></pre></td></tr></table></figure><p>const 引用常对象时只能访问该对象的<code>const 函数</code>。</p><h3 id="const型数据的小结"><a href="#const型数据的小结" class="headerlink" title="const型数据的小结"></a><strong>const型数据的小结</strong></h3><table><thead><tr><th>形式</th><th>含义</th></tr></thead><tbody><tr><td>Time <code>const</code> t1;<br /><code>const</code> Time t1;</td><td>t1是<code>常对象</code>，其值在任何情况下都不能改变(类似const int a=3;)。通过对象只能调用其const方法。</td></tr><tr><td><code>const</code> int hour;</td><td><code>常数据成员</code>，只能通过类的构造函数的参数初始化表对常数据成员进行初始化</td></tr><tr><td>void Time∷fun( )<code>const</code></td><td><code>常成员函数</code>，可以引用，但不能修改本类中的数据成员，可以引用const/非const数据成员。函数中只能调用const成员函数</td></tr><tr><td>Time * <code>const</code> p;</td><td><code>指向对象的常指针</code>，p的值(即p的指向)不能改变</td></tr><tr><td><code>const</code> Time *p;</td><td><code>指向常对象的指针</code>，其指向的类对象的值不能通过指针来改变。但是p可改变指向。对象属性值也可以通过类对象直接改变。</td></tr><tr><td><code>const</code> Time &amp;t1=t;</td><td><code>常引用</code>，t1是Time类对象t的引用，二者指向同一段内存空间,t值不能改变</td></tr></tbody></table><h3 id="10-对象的动态建立和释放"><a href="#10-对象的动态建立和释放" class="headerlink" title="10. 对象的动态建立和释放"></a>10. <strong>对象的动态建立和释放</strong></h3><ul><li>用new创建对象后，将返回一个<code>指向新对象的指针</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box *pt=<span class="keyword">new</span> <span class="built_in">Box</span>(<span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>);<span class="comment">//在pt中存放了新建对象的起始地址</span></span><br><span class="line">cout&lt;&lt;pt-&gt;height;           <span class="comment">//输出该对象的height成员</span></span><br></pre></td></tr></table></figure><ul><li>动态建立数组：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box *pt=<span class="keyword">new</span> Box[n];<span class="comment">//n为定义个int变量</span></span><br></pre></td></tr></table></figure><p>每个元素都会自动调用Box类的默认构造函数，若Box类没有默认构造函数，则创建对象失败。</p><p>若new对象失败，大多数C++编译系统返回一个0指针值。</p><p>不再需要由new建立的对象时，用delete运算符予以释放。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> pt;<span class="comment">//释放pt指向的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] pt;<span class="comment">//释放pt指向的数组空间</span></span><br></pre></td></tr></table></figure><h3 id="11-对象的赋值"><a href="#11-对象的赋值" class="headerlink" title="11. 对象的赋值"></a>11. <strong>对象的赋值</strong></h3><p>同类对象之间可以互相<code>赋值</code>，即一个对象的值（数据成员）赋给另一个同类的对象（被赋值对象已创建）。</p><blockquote><p>对象赋值格式：<br>    对象名1 = 对象名2; <code>//两个对象必须属于同一个类</code>。</p></blockquote><p>注意：</p><ol><li>对象的赋值只对其中的<code>数据成员</code>赋值，而不对成员函数赋值。</li><li>类的数据成员中<code>不能包括动态分配的数据</code>(new运算符建立的动态数据)，否则在赋值时可能出现严重后果。</li></ol><h3 id="12-对象的复制"><a href="#12-对象的复制" class="headerlink" title="12. 对象的复制"></a>12. <strong>对象的复制</strong></h3><p>用一个已有的对象复制出多个完全相同的对象（拷贝构造函数）。</p><blockquote><p>定义：<br>    类名(const 类名&amp; 对象名); </p></blockquote><p>​    参数：本类已有对象的引用，一般会用const修饰。</p><p>​    作用：将实参对象的<code>成员值</code>赋给新的对象中对应的成员，若没有定义复制构造函数，系统会自动创建一个。注意：同类对象之间可以访问对方的private变量。</p><div class="note info modern"><p>调用格式：<br>    类名 对象2(对象1)；//用对象1复制出对象2。<br>另一种调用格式：<br>    类名 对象1 = 对象2；//对象2已存在</p></div><div class="note warning modern"><ul><li><strong>对象的复制和对象的赋值的区别</strong>：<br>对象的赋值是对一个已经存在的对象赋值，因此必须先定义被赋值的对象，才能进行赋值。例如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box b1;</span><br><span class="line">b1=Box b2; <span class="comment">//b1已经定义，所以属于赋值</span></span><br></pre></td></tr></table></figure><p>对象的复制则是从无到有地建立一个新对象，并使它与一个已有的对象完全相同(包括对象的结构和成员的值)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box b1; </span><br><span class="line">Box b3=b1; <span class="comment">//新建box3，所以属于复制</span></span><br></pre></td></tr></table></figure></div><div class="note warning modern"><ul><li><strong>普通构造函数和复制构造函数的区别</strong>：<ul><li>形式上：复制构造函数的形参为本类引用<ul><li>类名(形参表列); //例如：<code>Box(int h,int w,int len)</code>;</li><li>类名(类名&amp; 对象名); //例如：<code>Box(const Box &amp;b)</code>;</li></ul></li><li>系统根据<code>实参的类型</code>选择调用的构造函数。</li><li>拷贝构造函数的被调情况<ol><li>新建一个对象，并用另一个同类的对象对它初始化。</li><li>构造函数的参数为同类的对象（有时会是临时对象，所以需要const修饰）。</li><li>继承时，子类的构造函数中用父类对象来对子类的子对象进行初始化（详见继承）。</li></ol></li></ul></li></ul></div><h3 id="13-静态数据成员"><a href="#13-静态数据成员" class="headerlink" title="13. 静态数据成员"></a>13. <strong>静态数据成员</strong></h3><p>静态数据成员：**<code>属于类</code>**，多个对象共有。关键字static。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">( )</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> height;  <span class="comment">//把height定义为静态的数据成员</span></span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>静态的数据成员在内存中只占一份空间。如果改变它的值，则在各对象中这个数据成员的值都同时改变了。</p><div class="note warning modern"><ol><li><p>只声明了类而未定义对象，类的一般数据成员不占内存空间。</p></li><li><p>类定义中有静态数据成员，不定义对象也为静态数据成员分配空间。</p></li><li><p>静态数据成员不随对象的建立而分配空间，也不随对象的撤销而释放。静态数据成员是在程序编译时被分配空间的，到程序结束时才释放空间。</p></li><li><p>静态数据成员可以初始化，但只能在<code>类体外</code>进行初始化。形式为：</p></li></ol><blockquote><p>数据类型  类名∷静态数据成员名=初值；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Box∷height=<span class="number">10</span>; <span class="comment">//对Box类中的static数据成员初始化</span></span><br></pre></td></tr></table></figure><p>不必在初始化语句中加static。不能用参数初始化表对静态数据成员初始化。例如：Box类中的static数据成员height： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Box</span>(<span class="keyword">int</span> h,<span class="keyword">int</span> w,<span class="keyword">int</span> len):<span class="built_in">height</span>(h)&#123; &#125;<span class="comment">//错误语句，height是静态数据成员</span></span><br></pre></td></tr></table></figure><ol start="5"><li>如果未对静态数据成员赋初值，则编译系统会自动赋予初值0。</li><li>静态数据成员既可以通过对象名引用，也可以通过类名来引用。若静态数据成员被定义为私有的，必须通过public成员函数引用。</li></ol></div><h3 id="14-静态成员函数"><a href="#14-静态成员函数" class="headerlink" title="14. 静态成员函数"></a>14. <strong>静态成员函数</strong></h3><p>格式：函数的前面加static</p><p>静态成员函数是类的一部分（类函数），而不是对象的一部分。</p><p>调用方式：</p><ul><li>用类名和域运算符“∷”</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">volume</span><span class="params">( )</span></span>;<span class="comment">//定义静态成员函数</span></span><br><span class="line">Box∷<span class="built_in">volume</span>( );<span class="comment">//通过类名调用静态成员函数</span></span><br></pre></td></tr></table></figure><ul><li>通过对象名调用：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="built_in">volume</span>( ); <span class="comment">//通过对象调用静态成员函数</span></span><br></pre></td></tr></table></figure><p>**静态成员函数只能直接访问本类的<code>静态成员</code>。 **</p><p><strong>要引用本类的非静态成员，需先建立本类对象，通过对象引用，如：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设a已定义为Box类对象</span></span><br><span class="line">cout&lt;&lt;a.width&lt;&lt;endl; <span class="comment">//通过本类对象a引用box类的非静态成员</span></span><br></pre></td></tr></table></figure><ul><li><strong>静态成员函数和普通成员函数的区别</strong><ul><li>静态成员函数不包含指向具体对象的this指针</li><li>普通成员函数包含一个指向具体对象的this指针。</li></ul></li></ul><h3 id="15-友元"><a href="#15-友元" class="headerlink" title="15. 友元"></a>15. <strong>友元</strong></h3><p>友元包括<code>友元函数</code>和<code>友元类</code>。</p><p>友元函数包括全局函数和类的成员函数，一个函数可以被多个类声明为“朋友”。</p><ul><li>将函数声明为友元函数，</li></ul><p>在类体中用friend对某个类外的函数(全局函数或其他类的成员函数)<code>进行声明</code>，此函数就称为本类的友元函数。友元函数可以访问这个类中的私有成员。例如：友元全局函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Time &amp;)</span></span>;  <span class="comment">//声明display函数为Time类的友元函数</span></span><br><span class="line">  <span class="keyword">private</span>:<span class="comment">//以下数据是私有数据成员</span></span><br><span class="line">     <span class="keyword">int</span> hour; ……</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Time&amp; t)</span> </span>&#123; <span class="comment">//Time类的友元函数，形参Time对象的引用</span></span><br><span class="line">  cout&lt;&lt;t.hour&lt;&lt;endl;  <span class="comment">//引用t的私有数据成员时，必须加上对象名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>友元成员函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span>   <span class="comment">//Date类的提前引用声明，若没有提前引用声明，编译会出错。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span>  <span class="comment">//类中的display函数将访问Data中的private数据。</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Time</span>(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>);<span class="comment">//声明构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Date &amp;)</span></span>; <span class="comment">//成员函数display是Date类的友元函数，形参是Date类对象的引用</span></span><br><span class="line">    ……  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span>  <span class="comment">//声明Date类，它的private数据可以被友元函数访问</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"><span class="comment">//声明Time中的display函数为友元成员函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> Time∷<span class="built_in">display</span>(Date &amp;); </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> month; <span class="comment">//Time类中的display可以通过对象访问private数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::display</span><span class="params">(Date &amp;d)</span></span>&#123; <span class="comment">//注意，只能位于正式声明类Date后，因为函数需要用到Date类的成员</span></span><br><span class="line">    cout&lt;&lt;d.month.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>友元类</li></ul><p>可以将一个类(例如B类)声明为另一个类(例如A类)的友元类。友元类B中的所有函数都是A类的友元函数，可以访问A类中的所有成员。</p><p><strong>声明友元类的形式为：</strong> <strong>friend</strong> <strong>类名；</strong></p><p>例如，在A类的定义体中用以下语句声明B类为其友元类：<br>        <code>friend B</code>;</p><div class="note warning modern"><p>友元使用注意：</p><ol><li>友元的关系是<code>单向</code>的而不是双向的。</li><li>友元的关系不能传递。</li><li>一般并不把整个类声明为友元类，而只将确实有需要的成员函数声明为友元函数</li></ol></div><h3 id="16-类模板"><a href="#16-类模板" class="headerlink" title="16. 类模板"></a>16. <strong>类模板</strong></h3><p>有两个或多个类，其功能相同，仅仅是数据类型不同，可以声明一个通用的类模板，它可以有<code>一个或多个</code>虚拟的类型参数。</p><p>定义及使用： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与函数模板类似</span></span><br><span class="line"><span class="comment">//注意，不要分号</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> 类型参数名&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line"><span class="comment">//定义类体，使用类型参数名来作为虚拟类型</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如p290：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">numtype</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Compare</span>(numtype a,numtype b)&#123;</span><br><span class="line">        x=a;y=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">numtype <span class="title">max</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>(x&gt;y)?x:y;&#125;</span><br><span class="line">    <span class="function">numtype <span class="title">mmin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>(x&lt;y)?x:y;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    numtype x,y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>利用类模板可以建立含多种数据类型的类。例如：</p><p>   <code> template &lt;class numtype&gt;</code><br>​     class Compare{ //类模板名为Compare<br>​         ……<br>​     }</p><ul><li><strong>使用类模板</strong></li></ul><blockquote><p>类模板名 &lt;实际类型名&gt; 对象名(参数表);</p></blockquote><p>   Compare cmp(4,7);  // 错误，Compare是类模板名，不是一个具体的类，类模板中的类型numtype并不是一个实际的类型，只是一个虚拟的类型，无法用它去定义对象。</p><p><code>Compare &lt;int&gt; cmp(4,7);</code>  //正确，进行编译时，编译系统就用int取代类模板中的类型参数numtype</p></blockquote><p>如果在<code>类模板外</code>定义成员函数，应写成类模板形式(函数模板)： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> 虚拟类型参数&gt;</span></span><br><span class="line">函数类型 类模板名&lt;虚拟类型参数&gt;∷成员函数名(函数形参表列) &#123;…&#125;</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">numtype</span>&gt;</span></span><br><span class="line">numtype Compare&lt;numtype&gt;::<span class="built_in">max</span>()&#123;<span class="keyword">return</span>(x&gt;y)?x:y;&#125;</span><br></pre></td></tr></table></figure><p>类模板使用说明： </p><ol><li>模板的类型参数可以有一个或多个，且每个类型前面都必须加class，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">someclass</span>&#123;</span>…&#125;;</span><br></pre></td></tr></table></figure><p>在定义对象时分别代入实际的类型名，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someclass&lt; <span class="keyword">int</span> , <span class="keyword">double</span> &gt; obj;</span><br></pre></td></tr></table></figure><ol start="2"><li>模板可以有层次，一个类模板可以作为基类，派生出派生模板类。</li><li>类模板的实现部分可以写在class内，也可以写在class外，但是<code>声明与实现必须在同一个文件内实现</code>。最好将类模板放在头文件内，其它文件使用时通过include包含即可(与函数模板类似)。</li></ol><h3 id="文档——const函数的重载"><a href="#文档——const函数的重载" class="headerlink" title="文档——const函数的重载"></a>文档——const函数的重载</h3><p>在使用const函数时，注意有一种重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">function</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">function</span> <span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在类中，由于隐含的this形参的存在，const的function函数使得作为形参的this指针的类型变为指向<code>const对象</code>的指针，而非const版本的使得作为形参的this指针就是正常版本的指针。此处是发生重载的本质。</p><p>重载函数在调用过程中，由于const对象只能调用其const函数，所以对于const对象调用的就选取const性质的成员函数，而普通的对象调用就选取非const性质的成员函数。</p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul><li><p>类的成员变量不能在定义时进行初始化</p></li><li><p>一个函数不能既作为重载函数，又作为有默认参数的函数</p></li><li><p>this指针存在的目的是，保证每个对象拥有自己的数据成员，但共享处理这些数据成员的代码在一个成员函数中经常需要调用其他函数（非本类的成员函数），而有时需要把当前对象（即对象的地址）作为参数传递给被调用函数，这时必须使用this指针。</p></li><li><p>静态成员函数对类的数据成员访问，只允许是静态数据成员</p></li><li><p>模板函数可以用同名的另一个模板函数重载。</p></li><li><p>拷贝构造函数的参数是，某个对象的引用名</p></li><li><p>析构函数，无形参，也不可重载</p></li><li><p>已知类A中的一个成员函数的说明如下：void Set(A &amp;a);则该函数的参数“A &amp;a”的含义是，类A对象引用a用作函数的形参</p></li><li><p>假定AB为一个类，则执行AB x；语句时将自动调用该类的，无参构造函数</p></li><li><p>定AB为一个类，则执行 “AB a(2), b[3], *p[4];”语句时共调用该类构造函数的次数为，4</p><p>——a(2)调用1次带参数的构造函数，b[3]调用3次无参数的构造函数，指针没有给它分配空间，没有调用构造函数，所以共调用构造函数的次数为4。</p></li><li><p>类A的成员函数void get()在类外定义时的函数首部为<code>void A::get()</code></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假定AA是一个类，“<span class="function">AA* <span class="title">abc</span><span class="params">()</span><span class="keyword">const</span></span>;”是该类中一个成员函数的原型，若该函数返回<span class="keyword">this</span>值，当用x.<span class="built_in">abc</span>()调用该成员函数后，x的值（ 不变</span><br><span class="line">假定AA是一个类，“<span class="function">AA&amp; <span class="title">abc</span><span class="params">()</span></span>;”是该类中一个成员函数的原型，若该函数存在对*<span class="keyword">this</span>赋值的语句，当用x.<span class="built_in">abc</span>()调用该成员函数后，x的值()已经被改变</span><br></pre></td></tr></table></figure><h1 id="第10章-运算符重载"><a href="#第10章-运算符重载" class="headerlink" title="第10章-运算符重载"></a>第10章-运算符重载</h1><h3 id="1-运算符重载的方法"><a href="#1-运算符重载的方法" class="headerlink" title="1. 运算符重载的方法"></a>1. <strong>运算符重载的方法</strong></h3><p>重载运算符的函数格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数类型 <span class="keyword">operator</span> 运算符名称 (形参表列)&#123;</span><br><span class="line">…… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>函数</code>实现复数相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span> <span class="comment">//复数类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> r,<span class="keyword">double</span> i):<span class="built_in">real</span>(r),<span class="built_in">imag</span>(i)&#123;&#125;</span><br><span class="line">    <span class="function">Complex <span class="title">complex_add</span><span class="params">(Complex &amp;c2)</span></span>; <span class="comment">//声明相加函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real;  <span class="comment">//实部</span></span><br><span class="line">    <span class="keyword">double</span> imag;  <span class="comment">//虚部</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complex::display</span><span class="params">()</span></span>&#123;<span class="comment">//定义输出函数</span></span><br><span class="line">cout&lt;&lt;“(”&lt;&lt;real&lt;&lt;“,”&lt;&lt;imag&lt;&lt;“i)”&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Complex <span class="title">Complex::complex_add</span><span class="params">(Complex &amp;c2)</span> <span class="comment">//定义复数相加函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex c;</span><br><span class="line">    c.real=real+c2.real;</span><br><span class="line">    c.imag=imag+c2.imag;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过<code>运算符重载</code>实现复数相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span><span class="comment">//复数类</span></span><br><span class="line">Complex <span class="keyword">operator</span> +(Complex &amp;c2); <span class="comment">//运算符重载函数</span></span><br><span class="line">&#125;;</span><br><span class="line">Complex Complex∷<span class="keyword">operator</span> +(Complex &amp;c2) &#123;</span><br><span class="line">Complex c;<span class="comment">//定义运算后返回的复数</span></span><br><span class="line">c.real=real+c2.real;  <span class="comment">//本对象的real与c2的real相加</span></span><br><span class="line">c.imag=imag+c2.imag;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">Complex c1(3,4), c2(5,-10), c3;</span><br><span class="line">c3=c1+c2;       <span class="comment">//运算符+用于复数运算</span></span><br><span class="line">cout&lt;&lt;″c1+c2=″;</span><br><span class="line">    c3.<span class="built_in">display</span>( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数实现与运算符重载都可以实现相同的功能</p><p>运算符被重载后，其原有功能仍然<code>保留</code>，编译器会根据表达式中的数据类型决定运算符的使用。</p><h3 id="2-重载运算符的规则"><a href="#2-重载运算符的规则" class="headerlink" title="2. 重载运算符的规则"></a>2. <strong>重载运算符的规则</strong></h3><ol><li>C++不允许用户自己定义新的运算符，只能对<code>已有</code>的运算符进行重载。</li><li>C++不允许重载的运算符<ul><li><code>.</code>    (成员访问运算符)</li><li><code>*</code>    (成员指针访问运算符)</li><li><code>∷</code>    (域运算符)</li><li><code>sizeof</code> (长度运算符)</li><li><code>?:</code>    (条件运算符)</li></ul></li><li>重载<code>不能改变</code>运算符运算对象(即操作数)的<code>个数</code>。</li><li>重载<code>不能改变</code>运算符的<code>优先级和结合性</code>。</li><li>重载运算符的函数<code>不能有默认的参数</code>。</li><li>重载的运算符必须和用户自定义类型的对象一起使用，其参数<code>至少有一个</code>是类对象(或类对象的引用)。即参数不能全部是C++的标准类型。</li><li>用于类对象的运算符一般必须重载，但是运算符<code>“=”</code>和<code>“&amp;”</code>不需用户重载。</li><li>应当使重载运算符的功能类似于该运算符作用于标准类型数据时所实现的功能。</li><li>运算符重载函数可以是类的成员函数(如上例)，也可以是类的友元函数(全局友元函数)。</li></ol><h3 id="3-运算符重载函数作为类成员函数和友元函数"><a href="#3-运算符重载函数作为类成员函数和友元函数" class="headerlink" title="3. 运算符重载函数作为类成员函数和友元函数"></a>3. <strong>运算符重载函数作为类成员函数和友元函数</strong></h3><p>将“+”重载为适用于复数加法，重载函数为类的全局友元函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">friend</span> Complex <span class="keyword">operator</span> + (Complex &amp;c1,Complex &amp;c2);<span class="comment">//成员函数作为运算符重载函数的参数是？</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义作为友元函数的运算符重载函数</span></span><br><span class="line">Complex <span class="keyword">operator</span> + (Complex &amp;c1, Complex &amp;c2)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Complex</span>(c1.real+c2.real, c1.imag+c2.imag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运算符重载函数的选择：</strong></p><ul><li>赋值运算符“=”、下标运算符“[]”、函数调用运算符“()”、成员运算符“-&gt;”<code>必须</code>作为<code>成员函数</code>重载。</li><li>流插入“&lt;&lt;”和流提取“&gt;&gt;”运算符、类型转换运算符不能定义为类的成员函数，<code>只能</code>做为<code>友元函数</code>。</li><li>一般将<code>单目</code>运算符和复合运算符重载为<code>成员函数</code>。</li><li>一般将<code>双目</code>运算符重载为<code>友元函数</code>。</li></ul><h3 id="4-重载双目运算符"><a href="#4-重载双目运算符" class="headerlink" title="4. 重载双目运算符"></a>4. <strong>重载双目运算符</strong></h3><p>定义一个字符串类String，用来存放不定长的字符串，重载运算符“==”“&lt;”“&gt;”，用于两个字符串的等于、小于和大于的比较运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>( )&#123; p=<span class="literal">NULL</span>; &#125;<span class="comment">//默认构造函数</span></span><br><span class="line"><span class="built_in">String</span>( <span class="keyword">char</span> *str )&#123;<span class="comment">//带参数构造函数</span></span><br><span class="line">p=str;<span class="comment">//p指向实参字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">( )</span></span>&#123;</span><br><span class="line">cout&lt;&lt;p&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> *p;<span class="comment">//字符型指针，用于指向字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">String string1(″Hello″),  string2(″Book″);</span><br><span class="line">string1.<span class="built_in">display</span>( );string2.<span class="built_in">display</span>( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载运算符“&gt;”……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//声明运算符函数为友元函数,&lt;,==一样</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(String &amp;string1,String &amp;string2);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt; (String &amp;string1,String &amp;string2) &#123;</span><br><span class="line"><span class="comment">//调用strcmp函数比较字符串大小</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(string1.p , string2.p)&gt;<span class="number">0</span>) <span class="comment">//&lt;,==</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-重载单目运算符"><a href="#5-重载单目运算符" class="headerlink" title="5. 重载单目运算符"></a>5. <strong>重载单目运算符</strong></h3><p>单目运算符只有一个操作数，因此运算符重载函数只有一个参数，如果运算符重载函数作为成员函数，则还可省略此参数。</p><p>有一个Time类，包含数据成员minute(分)和sec(秒)，模拟秒表，每次走一秒，满60秒进一分钟，此时秒又从0开始算。要求输出分和秒的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Time</span>( )&#123;minute=<span class="number">0</span>;sec=<span class="number">0</span>;&#125;<span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="comment">//构造函数重载，参数初始化表</span></span><br><span class="line">    <span class="built_in">Time</span>( <span class="keyword">int</span> m, <span class="keyword">int</span> s):<span class="built_in">minute</span>(m), <span class="built_in">sec</span>(s)&#123; &#125;</span><br><span class="line">    Time <span class="keyword">operator</span>++( );<span class="comment">//前置++</span></span><br><span class="line">    Time <span class="keyword">operator</span>++( <span class="keyword">int</span> );<span class="comment">//后置++</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">( )</span></span>&#123; cout&lt;&lt;minute&lt;&lt;″:″&lt;&lt;sec&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> minute;  <span class="comment">//分</span></span><br><span class="line">    <span class="keyword">int</span> sec;<span class="comment">//秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//前置++运算符重载函数</span></span><br><span class="line">Time Time∷<span class="keyword">operator</span>++( ) &#123; <span class="comment">//运算符重载函数实现部分</span></span><br><span class="line">    <span class="keyword">if</span>(++sec&gt;=<span class="number">60</span>) &#123;<span class="comment">//每次执行++，sec+1</span></span><br><span class="line">        sec-=<span class="number">60</span>;<span class="comment">//满60秒+1分钟，且sec-60</span></span><br><span class="line">        ++minute;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//返回当前对象值</span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="function">Time <span class="title">time1</span><span class="params">(<span class="number">34</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">61</span>;i++) &#123;</span><br><span class="line">        ++time1;</span><br><span class="line">        time1.<span class="built_in">display</span>( );&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++运算符重载函数</span></span><br><span class="line">Time Time∷<span class="keyword">operator</span>++( <span class="keyword">int</span> ) &#123; </span><br><span class="line">    <span class="function">Time <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;<span class="comment">//复制构造函数新建temp对象</span></span><br><span class="line">    <span class="keyword">if</span>(++sec&gt;=<span class="number">60</span>) &#123;<span class="comment">//每次执行++，sec+1</span></span><br><span class="line">        sec-=<span class="number">60</span>;<span class="comment">//满60秒+1分钟，且sec-60</span></span><br><span class="line">        ++minute;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;<span class="comment">//返回当前对象值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>int参数只是表明此为后置++运算符重载函数，此外没其他作用，且在进行后置++时不需要传递参数。</p></li><li><p>this为当前对象的指针，*this即当前对象</p></li><li><p>通过对象调用函数后，此对象内的sec+1，但是temp保留+1之前的值，且返回的是temp对象，即sec+1之前的值。例如：</p><pre><code>time2=time1++; </code></pre></li></ul><h3 id="6-重载流插入运算符和流提取运算符"><a href="#6-重载流插入运算符和流提取运算符" class="headerlink" title="6. 重载流插入运算符和流提取运算符"></a>6. <strong>重载流插入运算符和流提取运算符</strong></h3><ul><li><p>输入流类：<code>istream</code>。输出流类：<code>ostream</code>。cin和cout分别是istream类和ostream类的对象。在类中已经对“&lt;&lt;”和“&gt;&gt;”进行了重载，能用来输出和输入C++<code>标准类型的数据</code>。</p></li><li><p><code>自定义类型</code>的数据不能直接用“&lt;&lt;”和“&gt;&gt;” ，须重载。</p></li><li><p>**对“&lt;&lt;”和“&gt;&gt;”重载的函数形式如下： **</p></li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream  &amp; <span class="keyword">operator</span> &gt;&gt; (istream  &amp;, 自定义类 &amp;);</span><br><span class="line">ostream &amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;, 自定义类 &amp;);</span><br></pre></td></tr></table></figure></blockquote><p><strong>注：重载“&gt;&gt;”和“&lt;&lt;”的函数只能是友元函数。</strong></p><blockquote><p>假设用成员函数重载&lt;&lt;和&gt;&gt;，那么成员函数就只能本类对象才可以调用<br>，在使用&lt;&lt;/&gt;&gt;时必须写成：本类对象&lt;&lt;/&gt;&gt;cin/cout;<br>而不能写成:    cin&gt;&gt;s;     /    cout&lt;&lt;s;</p></blockquote><p>在前面Complex函数的基础上，用重载的“&lt;&lt;”输出复数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>( )&#123;real=<span class="number">0</span>;imag=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> r,<span class="keyword">double</span> i)&#123;real=r;imag=i;&#125;</span><br><span class="line">    <span class="comment">//运算符“+”重载为成员函数</span></span><br><span class="line">    Complex <span class="keyword">operator</span> + (Complex &amp;c2);</span><br><span class="line">    <span class="comment">//声明“&lt;&lt;”友元重载函数</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp;,Complex&amp;);    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real;</span><br><span class="line">    <span class="keyword">double</span> imag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义运算符“&lt;&lt;”重载函数</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; output, <span class="keyword">const</span> Complex&amp; c) &#123; </span><br><span class="line">output&lt;&lt;″(″&lt;&lt;c.real&lt;&lt;″+″&lt;&lt;c.imag&lt;&lt;″i)″&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    Complex c1(2,4),c2(6,10),c3;</span><br><span class="line">    c3=c1+c2;</span><br><span class="line">    <span class="comment">//“cout&lt;&lt;c3”解释为operator&lt;&lt;(cout,c3)</span></span><br><span class="line">    cout&lt;&lt;c3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-标准类型数据间的转换"><a href="#7-标准类型数据间的转换" class="headerlink" title="7. 标准类型数据间的转换"></a>7. <strong>标准类型数据间的转换</strong></h3><p>隐式类型转换，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">6</span>; </span><br><span class="line">i = <span class="number">7.5</span> + i; </span><br></pre></td></tr></table></figure><p>显式类型转换。形式为： 类型名(数据)，例如：<code>int(89.5) </code></p><p>注意：C语言中的显式类型转换的格式为： <code>(int)89.5</code></p><h3 id="8-转换构造函数"><a href="#8-转换构造函数" class="headerlink" title="8. 转换构造函数"></a>8. <strong>转换构造函数</strong></h3><p>转换构造函数：作用是将一个<code>其他类型的数据</code>转换成一个<code>类的对象</code>。</p><p>转换构造函数只有一个形参，例如： <code>Complex(double r) &#123; real=r; imag=0; &#125;</code></p><p>使用转换构造函数将一个指定的数据转换为类对象的方法如下：</p><ol><li>先声明一个类。</li><li>在这个类中定义一个只有一个参数的构造函数，参数的类型是需要转换的类型，在函数体中指定转换的方法。</li><li>在该类的作用域内可以用以下形式进行类型转换：<code>类名(指定类型的数据)</code></li></ol><p>注：不仅可以将一个<code>标准类型</code>数据转换成类对象，也可以将另一个<code>类的对象</code>转换成转换构造函数所在的类对象。</p><p>例如：将一个学生类对象转换为教师类对象，Teacher类中的转换构造函数： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Teacher</span>(Student&amp; s) &#123;</span><br><span class="line">num=s.num;  <span class="built_in">strcpy</span>(name,s.name);  sex=s.sex;&#125;</span><br></pre></td></tr></table></figure><p>注意： 对象s中的num,name,sex必须是公用成员，否则不能被类外引用</p><h3 id="9-类型转换函数"><a href="#9-类型转换函数" class="headerlink" title="9. 类型转换函数"></a>9. <strong>类型转换函数</strong></h3><p>转换构造函数：其他类型的数据→类的对象</p><p>类型转换函数：类的对象→其他类型的数据，注意，不是构造函数<br>    例如将一个Complex类对象转换成double类型数据</p><p>类型转换函数的一般形式为：</p><blockquote><p> operator 类型名( ) {</p><p>   实现转换的语句   }</p></blockquote><p>注意：</p><ul><li>在函数名前面不能指定函数类型，函数没有参数。其返回值的类型是由函数名中指定的类型名来确定的。</li><li>类型转换函数只能作为成员函数，因为转换的主体是本类的对象。不能作为友元函数或普通函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">Complex →<span class="keyword">double</span>，在Complex类中定义类型转换函数： </span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">( )</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> real;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><ul><li>假定M是一个类名，且M中重载了操作符=，可以实现M对象间的连续赋值，如“m1=m2=m3;”。重载操作符=的函数原型最好是（ ）<blockquote><p>M&amp; operator=(M);<br>连续赋值，返回值必定不是int,且m1=m2后，还有再次赋值，若返回M，则得到一个临时对象，临时对象不可以再次赋值，若返回M&amp;，则可以返回m1的引用，所以再次赋值，还是对m1的赋值。</p></blockquote></li></ul><ul><li>假定K是一个类名，并有定义“K k; int j;”，已知K中重载了操作符 ( )，且语句“j=k(3);”和“k(5)=99;”都能顺利执行，说明该操作符函数的原形只可能是（ ）</li></ul><blockquote><p>int &amp; operator ( )(int);</p><p>返回值可以赋值给int变量，还能接受int常量的赋值，所以返回值必须为int &amp;，两个调用参数都是常量，所以形参为int</p></blockquote><ul><li>如果表达式a+b中的“+”是作为成员函数重载的运算符，若采用运算符函数调用格式，则可表示为( )</li></ul><blockquote><p>a.operator+(b)</p><p>a+b，a+表示通过对象a调用operator+函数，参数为b</p></blockquote><ul><li>在一个类中可以对一个操作符进行（多种 ）重载。</li><li>C++中 函数参数的缺省值是什么？也就是函数默认值</li><li>定义类动态对象数组时，其元素只能靠自动调用该类的____________来进行初始化。   <code>无参构造函数</code></li><li>类型转换函数没有____________类型，而且参数表为____________。<code>返回值</code>,<code>空</code></li><li>重载抽取运算符&gt;&gt;时，其运算符函数的返回值类型应当是____________。<code>istream &amp;</code></li><li>重载运算符时，该运算符的__________、结合性以及操作符的个数不允许改变。<code>优先级</code></li></ul><h1 id="第11章-继承与派生"><a href="#第11章-继承与派生" class="headerlink" title="第11章-继承与派生"></a>第11章-继承与派生</h1><h3 id="1-继承与派生的概念"><a href="#1-继承与派生的概念" class="headerlink" title="1. 继承与派生的概念"></a>1. <strong>继承与派生的概念</strong></h3><p>子类继承了基类的<code>所有数据成员和成员函数</code>(除了构造函数和析构函数)，并可以调整成员的属性(访问范围等)。</p><p>一个子类只从一个基类派生，这称为单继承（java）</p><p>一个派生类不仅可以从一个基类派生，也可以从<code>多个基类</code>派生。一个派生类有两个或多个基类的称为多重继承（C++）</p><h3 id="2-派生类的声明方式"><a href="#2-派生类的声明方式" class="headerlink" title="2. 派生类的声明方式"></a>2. <strong>派生类的声明方式</strong></h3><p>声明子类的形式:</p><blockquote><p>class 派生类名:［继承方式］基类名{<br>    派生类新增加的成员<br>} ;</p></blockquote><p>继承方式: public,private和protected，如果不写此项，<code>默认为private</code>。</p><p>例：假设已经声明了基类Stu，在此基础上通过单继承建立子类Stu1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu1</span>:</span> <span class="keyword">public</span> Stu &#123;  <span class="comment">//基类Student，继承方式public</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_1</span><span class="params">( )</span> </span>&#123;<span class="comment">//新增加的成员函数</span></span><br><span class="line">cout&lt;&lt;″age: ″&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> age; <span class="comment">//新增加的数据成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-类图"><a href="#3-类图" class="headerlink" title="3. 类图"></a>3. <strong>类图</strong></h3><ul><li><p>属性和方法书写规范：修饰符[描述信息] 属性、方法名称 [参数] [：返回类型|类型]</p></li><li><p>属性和方法之前可附加的可见性修饰符：<br>加号（+）表示public；减号（-）表示private；井号(#)表示protected；</p></li><li><p>继承关系：子类箭头指向父类。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/keysuri/img/postimages/%E5%9B%BE%E7%89%871.png"></p><h3 id="4-派生类的构成"><a href="#4-派生类的构成" class="headerlink" title="4. 派生类的构成"></a>4. <strong>派生类的构成</strong></h3><p>子类包括从基类继承过来的成员(数据与方法)和增加的成员两部分。</p><p><img src="https://cdn.jsdelivr.net/gh/keysuri/img/postimages/%E5%9B%BE%E7%89%872.png"></p><p>构造一个派生类包括以下3部分工作: </p><ol><li>从基类接收成员。注意：<code>不包括构造函数和析构函数</code> </li><li>调整从基类接收的成员。可以对继承来的成员作某些调整。</li></ol><blockquote><p>例如：</p><p>改变派生类中基类域中成员的访问属性。<br>派生类中声明一个与基类同名的成员。</p></blockquote><ol start="3"><li>在声明派生类中增加的成员。</li></ol><h3 id="5-派生类成员的访问属性"><a href="#5-派生类成员的访问属性" class="headerlink" title="5. 派生类成员的访问属性"></a>5. <strong>派生类成员的访问属性</strong></h3><p>派生类中的基类域成员和子类域成员的访问情况：</p><ol><li>基类的成员函数访问基类成员。</li><li>派生类的成员函数访问派生类自己增加的成员。</li><li>基类的成员函数<code>不可</code>访问派生类的成员。</li><li><strong>派生类的成员函数访问基类的成员。</strong></li><li>在派生类外只能访问派生类的<code>公用成员</code>。</li><li><strong>在派生类外访问基类的成员。</strong></li></ol><p>第(4)和(6)：根据基类的成员在派生类中的访问属性，要考虑基类成员所声明的访问属性，且要考虑派生类所声明的继承方式，根据这两个因素共同决定基类成员在派生类中的访问属性。</p><ul><li><strong>公用继承：继承方式为public的继承。</strong></li></ul><blockquote><p> 注意：在子类中只能通过调用基类的公用成员函数来引用基类的私有数据成员。</p></blockquote><ul><li><strong>私有继承：继承方式为private的继承。</strong></li></ul><blockquote><ol><li>不能通过派生类<code>对象</code>访问从基类<code>私有</code>继承过来的<code>任何成员</code>。</li><li>派生类的<code>成员函数</code>不能访问<code>基类的private成员</code>，但可以访问基类的<code>public成员</code>。</li><li>可以通过派生类的<code>成员函数</code>调用基类的<code>public成员函数</code>,通过基类的public函数访问基类中的private成员，从而让派生类访问基类中的private成员。</li></ol></blockquote><ul><li><strong>保护继承：继承方式为protected的继承。</strong></li></ul><blockquote><p>保护成员可以被派生类的<code>成员函数</code>引用（类外不可以访问）。</p></blockquote><ul><li><strong>基类成员在派生类中的访问属性</strong></li></ul><table><thead><tr><th align="center">在基类的访问属性</th><th align="center">继承方式</th><th align="center">在派生类中的访问属性</th></tr></thead><tbody><tr><td align="center"><code>private</code></td><td align="center">public</td><td align="center"><code>不可访问</code></td></tr><tr><td align="center"><code>private</code></td><td align="center">private</td><td align="center"><code>不可访问</code></td></tr><tr><td align="center"><code>private</code></td><td align="center">protected</td><td align="center"><code>不可访问</code></td></tr><tr><td align="center">public</td><td align="center">public</td><td align="center">public</td></tr><tr><td align="center">public</td><td align="center">private</td><td align="center">private</td></tr><tr><td align="center">public</td><td align="center">protected</td><td align="center">protected</td></tr><tr><td align="center">protected</td><td align="center">public</td><td align="center">protected</td></tr><tr><td align="center">protected</td><td align="center">private</td><td align="center">private</td></tr><tr><td align="center">protected</td><td align="center">protected</td><td align="center">protected</td></tr></tbody></table><ul><li><strong>派生类中的成员访问属性</strong></li></ul><table><thead><tr><th align="center">派生类中访问属性</th><th align="center">在派生类中</th><th align="center">在派生类外部</th><th align="center">在下一层公用派生类中</th></tr></thead><tbody><tr><td align="center">公用</td><td align="center">可以</td><td align="center">可以</td><td align="center">可以</td></tr><tr><td align="center">保护</td><td align="center">可以</td><td align="center">不可以</td><td align="center">可以</td></tr><tr><td align="center">私有</td><td align="center">可以</td><td align="center">不可以</td><td align="center">不可以</td></tr><tr><td align="center">不可访问</td><td align="center">不可以</td><td align="center">不可以</td><td align="center">不可以</td></tr></tbody></table><ul><li><strong>多级派生时的访问属性</strong><ul><li>无论哪一种继承方式，在派生类中是不能访问基类的私有成员的，私有成员只能被本类的成员函数所访问;</li><li>如果采用私有继承，经过若干次派生后，基类的所有的成员会变成不可访问。</li></ul></li></ul><h3 id="6-简单派生类的构造函数"><a href="#6-简单派生类的构造函数" class="headerlink" title="6. 简单派生类的构造函数"></a>6. <strong>简单派生类的构造函数</strong></h3><p>简单派生类构造函数格式：</p><blockquote><p>派生类构造函数名(总参数表列): 基类构造函数名(参数表列)<br>    { 派生类中新增数据成员初始化语句 }</p></blockquote><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student1</span>(<span class="keyword">int</span> n,string nam,<span class="keyword">char</span> s,<span class="keyword">int</span> a,string ad):<span class="built_in">Student</span>(n,nam,s)</span><br><span class="line">&#123;      ……      &#125;</span><br></pre></td></tr></table></figure><p>注意：总参数表列中包含<code>基类</code>与<code>派生类</code>中所需的所有参数，参数格式为<code>参数类型</code>和<code>参数名</code>。</p><p>冒号后面的“基类构造函数名(参数表列)” 为<code>调用基类构造函数</code>，所以它的这些参数是实参。它们可以是：常量、全局变量和总参数表列中的参数。</p><p>调用基类构造函数时的实参也可以不从派生类构造函数的总参数表中传递过来，而直接使用常量或全局变量。例: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student1</span>(string nam，<span class="keyword">char</span> s，<span class="keyword">int</span> a，string ad):<span class="built_in">Student</span>(<span class="number">10010</span>，nam，s)</span><br></pre></td></tr></table></figure><p>注意：编译系统是根据参数的<code>名称</code>来确认总参数表与基类构造函数实参之间的传递关系的，而不是参数的排列顺序。</p><p>在建立一个对象时，执行构造函数的顺序是:(自然析构顺序就知道了)</p><ol><li>调用基类构造函数；</li><li>执行派生类构造函数；</li></ol><h3 id="7-有子对象的派生类的构造函数"><a href="#7-有子对象的派生类的构造函数" class="headerlink" title="7. 有子对象的派生类的构造函数"></a>7. <strong>有子对象的派生类的构造函数</strong></h3><p>子对象：以类的实例作为类中的数据成员。</p><p>子对象可以是派生类的父类，也可以是其他类。</p><p>定义派生类构造函数的一般形式为：</p><blockquote><p>派生类构造函数名（总参数表列）: 基类构造函数名（参数表列），<code>子对象名(参数表列) </code>{<br>        派生类中新增数成员据成员初始化语句<br>}</p></blockquote><p>执行派生类构造函数的顺序是: </p><ol><li>调用基类构造函数，对基类数据成员初始化；</li><li>调用子对象构造函数，对子对象数据成员初始化；</li><li>再执行派生类构造函数本身，对派生类数据成员初始化。</li></ol><p>派生类构造函数的总参数表列中的参数，包括基类构造函数和子对象的参数表列中的参数。</p><p>基类构造函数和子对象的次序可以是任意的，编译系统是根据<code>相同的参数名</code>(而不是根据参数的顺序)来确立它们的传递关系的。</p><h3 id="8-多层派生时的构造函数"><a href="#8-多层派生时的构造函数" class="headerlink" title="8. 多层派生时的构造函数"></a>8. <strong>多层派生时的构造函数</strong></h3><blockquote><p>多层派生类的构造函数：<br>每个类的构造函数只需写出其父类的构造函数。<br>构建对象时需要在参数列表中给出本类及多层父类的初始化参数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span> </span><br><span class="line"><span class="built_in">Student</span>(<span class="keyword">int</span> n, string name) &#123; …… &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span>:</span><span class="keyword">public</span> Student&#123;</span><br><span class="line"><span class="built_in">Student1</span>(<span class="keyword">int</span> n, string name,<span class="keyword">int</span> a) : <span class="built_in">Student</span>(n,name)</span><br><span class="line">&#123; …… &#125;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2</span>:</span><span class="keyword">public</span> Student1&#123;</span><br><span class="line"><span class="built_in">Student1</span>(<span class="keyword">int</span> n, string name,<span class="keyword">int</span> a,<span class="keyword">int</span>  s): <span class="built_in">Student1</span>(n,name,a) &#123; …… &#125;&#125;;</span><br></pre></td></tr></table></figure><h3 id="9-派生类构造函数的特殊形式"><a href="#9-派生类构造函数的特殊形式" class="headerlink" title="9. 派生类构造函数的特殊形式"></a>9. <strong>派生类构造函数的特殊形式</strong></h3><ul><li>子类属性若不需要赋值，子类的构造函数可以为空函数。</li><li>父类仅有默认构造函数，子类的构造函数不需要调用父类构造函数（自动调用）。</li><li>父类和子类都是默认构造函数，且子类无属性赋值，子类可以无构造函数（自动调用默认构造函数）。</li><li>父类中既有无参构造函数，又有带参构造函数，子类中既可以包含基类构造函数及其参数，也可以不包含基类构造函数。</li></ul><h3 id="10-多重继承"><a href="#10-多重继承" class="headerlink" title="10. 多重继承"></a>10. 多重继承</h3><ul><li>多重继承: 一个子类有两个或多个基类，派生类从两个或多个基类中继承所需的属性。</li></ul><p>声明多重继承的方法：</p><blockquote><p>class 子类名:继承方式 父类名, … ,继承方式 父类名<br>    {     …     }</p></blockquote><p>例如：如果已声明了类A、类B和类C，声明多重继承的派生类D:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> A, <span class="keyword">private</span> B, <span class="keyword">protected</span> C&#123;</span><br><span class="line">类D新增加的成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>构造函数：</strong></li></ul><blockquote><p>子类构造函数名(总参数表列): 基类1构造函数(参数表列), 基类2构造函数(参数表列), 基类3构造函数 (参数表列)<br>{    派生类中新增数成员据成员初始化语句    }</p></blockquote><p>调用基类构造函数的顺序是按照声明子类时基类出现的顺序。</p><ul><li><strong>多重继承引起的二义性问题</strong></li></ul><p>二义性：多重继承时，继承的<code>多个基类中有名称相同的成员</code>。</p><p><strong>情况1: 两个基类有同名成员</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">( )</span></span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">( )</span></span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">C c1;</span><br><span class="line">c1.a=<span class="number">3</span>;c1.<span class="built_in">display</span>();   <span class="comment">//错误信息，成员有歧义。</span></span><br><span class="line">c1.A::a=<span class="number">3</span>;   <span class="comment">//引用c1对象中的基类域A的数据成员a，通过作用域限定符消除歧义</span></span><br><span class="line">c1.B::<span class="built_in">display</span>();  <span class="comment">//调用c1中的基类域B的成员函数display，通过作用域限定符消除歧义</span></span><br></pre></td></tr></table></figure><p><strong>情况2: 基类和派生类三者都有同名成员</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">( )</span></span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">( )</span></span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">C c1;</span><br><span class="line">c1.a=<span class="number">3</span>;c1.<span class="built_in">display</span>();   <span class="comment">//访问的是C中的成员。</span></span><br><span class="line">c1.A::a=<span class="number">3</span>;   <span class="comment">//引用c1中的基类域A的数据成员a，通过作用域限定符指定访问</span></span><br><span class="line">c1.B::<span class="built_in">display</span>();  <span class="comment">//调用c1中的基类域B的成员函数display</span></span><br></pre></td></tr></table></figure><div class="note warning modern"><p>注意：子类中只要出现与基类中<code>同名</code>的函数，不管参数是否相同，通过<code>子类对象</code>调用函数时，基类的函数都将被屏蔽。若要访问，需通过::运算符。</p></div><p><strong>情况3: 类A和类B是从同一个基类派生的,AB自动产生了相同名称的成员</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">N</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">( )</span></span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a1; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a2;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="keyword">int</span> a3;  <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;     &#125;;</span><br><span class="line">c1.A::a=<span class="number">3</span>; </span><br><span class="line">c1.A::<span class="built_in">display</span>(); <span class="comment">//要访问的是类N的派生类A中的基类成员</span></span><br></pre></td></tr></table></figure><h3 id="11-虚基类"><a href="#11-虚基类" class="headerlink" title="11. 虚基类"></a>11. <strong>虚基类</strong></h3><p>虚基类的作用：在继承间接共同基类时只保留一份成员。</p><blockquote><p>声明虚基类形式如下:<br>    class 派生类名: virtual 继承方式 基类名</p></blockquote><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>…&#125;;<span class="comment">//声明基类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> A </span><br><span class="line">&#123;…&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> A </span><br><span class="line">&#123;…&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span><span class="keyword">public</span> B,<span class="keyword">public</span> C</span><br><span class="line">&#123;…&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：为了保证虚基类在派生类中只继承一次，应当在该基类的<code>所有直接派生类</code>中声明为虚基类。否则仍然会出现对基类的多次继承 </p><p><strong>虚基类的初始化</strong>：若在虚基类中定义了带参数的构造函数，且没有默认构造函数，则在其<code>所有派生类</code>(包括直接派生或间接派生的派生类)中，需要通过构造函数的初始化表对虚基类进行初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>    <span class="comment">//定义基类A</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i)&#123; &#125;     <span class="comment">//基类构造函数，为public</span></span><br><span class="line">    <span class="keyword">int</span> data; …  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> n):<span class="built_in">A</span>(n)&#123; &#125;   <span class="comment">//在初始化表中对虚基类初始化</span></span><br><span class="line">    …&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="keyword">int</span> n):<span class="built_in">A</span>(n)&#123; &#125; …    &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span><span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line">    <span class="built_in">D</span>(<span class="keyword">int</span> n):<span class="built_in">A</span>(n),<span class="built_in">B</span>(n),<span class="built_in">C</span>(n)&#123; &#125;    <span class="comment">//在最后的派生类中不仅要负责对其直接基类进行初始化，还要负责对虚基类初始化</span></span><br><span class="line">    …&#125;;</span><br><span class="line"><span class="comment">//编译系统只执行最后的派生类对虚基类的构造函数的调用，而忽略虚基类的其他派生类(如类B和类C) 对虚基类的构造函数的调用，这就保证了虚基类的数据成员不会被多次初始化</span></span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span> <span class="comment">//声明公共基类Person</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Person</span>(string nam,<span class="keyword">char</span> s,<span class="keyword">int</span> a) </span><br><span class="line">   &#123;name=nam;sex=s;age=a;&#125;</span><br><span class="line"><span class="keyword">protected</span>:         </span><br><span class="line">   string name;</span><br><span class="line">   <span class="keyword">char</span> sex;</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Person&#123; </span><br><span class="line"><span class="keyword">public</span>:                                 </span><br><span class="line">   <span class="built_in">Teacher</span>(string nam,<span class="keyword">char</span> s,<span class="keyword">int</span> a, string t):<span class="built_in">Person</span>(nam,s,a) </span><br><span class="line">    &#123;title=t; &#125;</span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">string title;    <span class="comment">//职称</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Person&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Student</span>(string nam,<span class="keyword">char</span> s,<span class="keyword">int</span> a,<span class="keyword">float</span> sco)   </span><br><span class="line">      :<span class="built_in">Person</span>(nam,s,a),<span class="built_in">score</span>(sco)&#123; &#125;    </span><br><span class="line"><span class="keyword">protected</span>:               </span><br><span class="line">    <span class="keyword">float</span> score;                            </span><br><span class="line"> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graduate</span>:</span><span class="keyword">public</span> Teacher, <span class="keyword">public</span> Student&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graduate</span>(string nam,<span class="keyword">char</span> s,<span class="keyword">int</span> a, string t,<span class="keyword">float</span> sco,<span class="keyword">float</span> w) </span><br><span class="line">:<span class="built_in">Person</span>(nam,s,a),<span class="built_in">Teacher</span>(nam,s,a,t),<span class="built_in">Student</span>(nam,s,a,sco),<span class="built_in">wage</span>(w)&#123;&#125;</span><br><span class="line"><span class="comment">//上述参数初始化表，Person初始化了虚基类。且不会调用Teacher与Student中的基类构造函数，但在Graduate中调用他们构造函数时参数还需要对应其参数表。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function">    </span>&#123;cout&lt;&lt;″name:″&lt;&lt;name&lt;&lt;endl;<span class="comment">//直接调用</span></span><br><span class="line">     cout&lt;&lt;″age:″&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">     cout&lt;&lt;″sex:″&lt;&lt;sex&lt;&lt;endl;</span><br><span class="line">     cout&lt;&lt;″score:″&lt;&lt;score&lt;&lt;endl;</span><br><span class="line">     cout&lt;&lt;″title:″&lt;&lt;title&lt;&lt;endl;</span><br><span class="line">     cout&lt;&lt;″wages:″&lt;&lt;wage&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> wage;                     <span class="comment">//工资</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h3 id="12-基类与派生类的转换-向上转型"><a href="#12-基类与派生类的转换-向上转型" class="headerlink" title="12. 基类与派生类的转换(向上转型)"></a>12. <strong>基类与派生类的转换(向上转型)</strong></h3><p>公用派生类完整地继承了基类的功能，派生类中包含从基类继承的成员，因此可以将派生类的值赋给基类对象，在用到基类对象的时候可以用其子类对象代替。</p><p><strong>(情况1) 派生类对象赋值给基类：用public子类对象对其基类对象<code>赋值</code>。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如: <span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">A a1; </span><br><span class="line">B b1;     <span class="comment">//类A的public子类B的对象b1</span></span><br><span class="line">a1=b1;  <span class="comment">//子类B对象b1对基类对象a1赋值</span></span><br></pre></td></tr></table></figure><p>派生类对象可以向基类对象赋值<br>赋值只是对数据成员赋值，对成员函数不存在赋值问题。 </p><p>注意: 赋值后不能通过对象a1去访问派生类对象b1中新增的成员（不存在）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假设A类有成员数据name，而age是子类B中增加的公用数据成员。</span><br><span class="line">A a1; </span><br><span class="line">B b1;     <span class="comment">//类A的public子类B的对象b1</span></span><br><span class="line">a1=b1;</span><br><span class="line">a1.name=“xiaoming”;  <span class="comment">//正确</span></span><br><span class="line">a1.age=<span class="number">23</span>;   <span class="comment">//错误</span></span><br><span class="line">b1.age=<span class="number">21</span>;   <span class="comment">//正确</span></span><br><span class="line">b1.name=“xiaohong”; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><div class="note danger modern"><ul><li>子类型关系是单向的、不可逆的</li><li>只能用子类对象对其基类对象赋值，而不能用基类对象对其子类对象赋值</li><li>同一基类的不同子类对象之间也不能互相赋值</li></ul></div><p><strong>(情况2) 子类对象可以替代基类对象向基类对象的引用进行赋值或初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如已定义了基类A对象a1，可以定义a1的引用变量:</span><br><span class="line">A a1; <span class="comment">//定义基类A对象a1</span></span><br><span class="line">B b1; <span class="comment">//定义public子类B对象b1</span></span><br><span class="line">A&amp; r=a1; <span class="comment">//定义基类A对象的引用变量r，并用a1对其初始化</span></span><br><span class="line"><span class="comment">//或者上面一行的代码改为：</span></span><br><span class="line">A&amp; r=b1; <span class="comment">//用派生类B对象b1对A类对象的引用进行初始化</span></span><br><span class="line"><span class="comment">//或者保留 “A&amp; r=a1;”，而对r重新赋值：</span></span><br><span class="line">r=b1;<span class="comment">//用派生类B对象b1对a1的引用变量r赋值</span></span><br></pre></td></tr></table></figure><p>注意: 此时r并不是b1的别名，也不与b1共享同一段存储单元。它只是<code>b1中基类部分的别名</code>，r与b1中基类部分共享同一段存储单元，r与b1具有相同的起始地址。</p><p><strong>(情况3) 如果函数的参数是基类对象或基类对象的引用，相应的实参可以用子类对象.</strong></p><p>例如函数fun: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(A&amp; r)</span> </span>&#123; <span class="comment">//形参是类A的对象的引用变量</span></span><br><span class="line">cout&lt;&lt;r.num&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数调用时：</span></span><br><span class="line"> <span class="built_in">fun</span>(b1);</span><br></pre></td></tr></table></figure><p><strong>(情况4)子类对象的地址可以赋给指向基类对象的指针变量。</strong></p><p>定义一个基类Student(学生)，再定义Student类的public子类Graduate(研究生)，用指向基类对象的指针输出数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Student <span class="title">stud1</span><span class="params">(<span class="number">1001</span>,″Li″,<span class="number">87.5</span>)</span></span>; </span><br><span class="line"><span class="function">Graduate <span class="title">grad1</span><span class="params">(<span class="number">2001</span>,″Wang″,<span class="number">98.5</span>,<span class="number">563.5</span>)</span></span>; </span><br><span class="line">Student *pt=&amp;stud1; </span><br><span class="line">pt-&gt;<span class="built_in">display</span>( );<span class="comment">//调用stud1.display函数</span></span><br><span class="line">pt=&amp;grad1;<span class="comment">//指针指向grad1</span></span><br><span class="line">pt-&gt;<span class="built_in">display</span>( );<span class="comment">//调用grad1.display函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>pt是指向Student类对象的指针变量，即使让它指向了grad1，但实际上pt指向的是grad1中从基类继承的部分。</p></li><li><p>通过指向基类对象的指针，只能访问派生类中的基类成员，而不能访问派生类增加的成员。所以pt-&gt;display()调用的不是派生类Graduate对象所增加的display函数，而是基类的display函数.</p></li></ul><h3 id="13-继承与组合"><a href="#13-继承与组合" class="headerlink" title="13. 继承与组合"></a>13. <strong>继承与组合</strong></h3><ul><li>在一个类中可以用类对象作为数据成员，即子对象</li><li>对象成员的类型可以是本派生类的基类，也可以是另外一个已定义的类。</li><li>在一个类中以另一个类的对象作为数据成员的，称为类的组合</li><li>类的组合和继承的区别：<ul><li>通过继承建立了派生类与基类的关系</li><li>通过组合建立了成员类和组合类的关系</li><li>继承是纵向的，组合是横向的</li></ul></li></ul><h3 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h3><ul><li><p>派生类只含有基类的公有成员和保护成员  ×   <strong>private也继承，只是不能访问</strong></p></li><li><p>派生类的构造函数的成员初始化列表中，不能包含（ ）。 <strong>基类中子对象的初始化</strong></p></li><li><p><code>派生类的对象</code>对其基类成员中（ ）是可以访问的。 <strong>公有继承中的公有成员</strong></p></li><li><p>在私有继承的情况下，允许<code>派生类</code>直接访问的基类成员包括（）。<strong>公有成员和保护成员</strong></p></li><li><p><strong>无论何种继承方式，基类中的private在子类中<code>都不可访问</code></strong></p></li></ul><h1 id="第12章-多态性与虚函数"><a href="#第12章-多态性与虚函数" class="headerlink" title="第12章-多态性与虚函数"></a>第12章-多态性与虚函数</h1><h3 id="1-多态性的概念"><a href="#1-多态性的概念" class="headerlink" title="1. 多态性的概念"></a>1. <strong>多态性的概念</strong></h3><p>从系统实现的角度看，多态性分为两类: 静态多态性和动态多态性。</p><ul><li>静态多态性：由函数重载实现，由于重载函数的参数不同，所以在程序编译时系统就能决定要调用哪个函数，又称为<code>编译时</code>的多态性。</li></ul><div class="note warning modern"><p>注意：函数只有在<code>同一个作用域内</code>才能构成重载。例如同一个类内，或者几个同名函数都是全局函数。注意：继承的子类中与父类域中的同名函数不构成重载(构成重写，从而隐藏)</p></div><ul><li>动态多态性：不在编译时确定调用的是哪个函数，而是在程序运行过程中才动态地确定操作所针对的对象。它又称<code>运行时</code>的多态性。动态多态性通过虚函数实现。</li></ul><h3 id="2-一个典型的例子-重载实现多态"><a href="#2-一个典型的例子-重载实现多态" class="headerlink" title="2. 一个典型的例子(重载实现多态)"></a>2. <strong>一个典型的例子(重载实现多态)</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream&amp;,<span class="keyword">const</span> Point &amp;);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span><span class="keyword">public</span> Point&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream&amp;,<span class="keyword">const</span> Circle &amp;);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">Class Cylinder:<span class="keyword">public</span> Circle&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream&amp;,<span class="keyword">const</span> Cylinder &amp;);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述三个类中声明的friend函数名称都为operator&lt;&lt;，但参数不同，且这三个operator&lt;&lt;函数都属于<code>全局函数</code>，构成重载，所以在main函数中通过参数即可在编译阶段确认调用的函数，属于静态多态性，即编译时多态。</p></blockquote><h3 id="3-利用虚函数实现动态多态性"><a href="#3-利用虚函数实现动态多态性" class="headerlink" title="3. 利用虚函数实现动态多态性"></a>3. <strong>利用虚函数实现动态多态性</strong></h3><p>虚函数：类中被关键字virtual修饰的成员函数。</p><p>功能：基类中声明为virtual的函数，在子类中重写一个<code>名称相同</code>，<code>参数相同的函数</code>。在将子类<code>对象/对象地址</code>赋值给<code>基类引用/基类指针</code>后，通过<code>基类</code>引用/基类指针可以调用<code>子类中</code>重写的函数(而不是基类域中的同名函数)。</p><div class="note warning modern"><ul><li>基类中的虚函数，其子类中的同名同参数函数会自动成为虚函数。(即子类中可以不写<code>virtual</code>)</li><li>C++标准允许<code>返回值不同</code>的情况，但是只有极少的编译器支持，所以程序中重写的虚函数需要与基类中的保持<code>返回值</code>、<code>函数名</code>、<code>参数</code>都一致(若参数不一致，则不构成重写关系，不构成多态)。</li><li>只能用virtual声明类的成员函数为虚函数。</li><li>同类中不能定义相同名称与参数的函数，即使返回值不同也不行（提示错误：无法构成重载）。</li></ul></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>&#123;</span><span class="comment">//定义基类Parent</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;cout&lt;&lt;“Parent cout!”&lt;&lt;endl; &#125;   &#125;;<span class="comment">//定义虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Parent&#123; <span class="comment">//定义子类son</span></span><br><span class="line"><span class="comment">//show(int)因参数不同，没有重写基类中的show，而是与重写的show构成了重载关系。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;  cout&lt;&lt;“Son cout include i!”&lt;&lt;endl;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;  cout&lt;&lt;“Son cout!”&lt;&lt;endl;    &#125; <span class="comment">//重写虚函数show，</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Parent  f, *pf;      Son s; </span><br><span class="line">    f=s; <span class="comment">//子类对象s赋值给基类对象f，向上转型</span></span><br><span class="line">    f.<span class="built_in">show</span>(); <span class="comment">//基类对象，调用的是基类中的show函数。</span></span><br><span class="line">    pf=&amp;s; <span class="comment">//将子类对象s的地址赋值给基类指针pf</span></span><br><span class="line">    pf-&gt;<span class="built_in">show</span>(); <span class="comment">//通过指针，调用的是子类中的show（即多态）</span></span><br><span class="line">    <span class="comment">//pf-&gt;show(12); //错误,提示找不到fa::show(int)匹配的函数</span></span><br><span class="line">    Parent &amp;pa=s;     <span class="comment">//定义基类引用并用子对象初始化</span></span><br><span class="line">    pa.<span class="built_in">show</span>();  <span class="comment">//通过引用实现多态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虚函数的使用方法：</li></ul><ol><li>在基类用virtual关键字声明成员函数为虚函数。</li><li>在子类中重写此函数，要求函数名、函数类型、函数参数与基类的虚函数相同。</li><li>定义一个指向基类对象的指针变量/引用，并使它指向同一类族中需要调用该函数的对象。</li><li>通过该指针变量/引用调用此虚函数，此时调用的就是指针变量指向的对象的同名函数。</li></ol><ul><li>静态关联与动态关联<ul><li>确定调用函数的具体对象的过程称为关联/绑定。</li><li>函数重载在编译时即可确定其调用的函数属于哪一个类，其过程称为静态关联，也称为早期关联。</li><li>多态中，通过基类指针/引用调用虚函数，在编译阶段无法从语句本身确定调用哪一个类的虚函数，只有在运行时，根据基类指针/引用指向某个对象(所以前面需要将对象/地址赋给指针/引用)，才能确定调用的是哪一个类的虚函数。其过程为动态关联，也称为滞后关联。</li></ul></li></ul><h3 id="4-虚析构函数"><a href="#4-虚析构函数" class="headerlink" title="4. 虚析构函数"></a>4. <strong>虚析构函数</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destruct A&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; destruct B&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A * a = <span class="keyword">new</span> B;</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>输出：<br>destruct A<br>delete a;<br>表示释放A类型指针指向的动态空间。所以调用的是类A的析构函数。导致B类中创建的内存不能释放。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span>  ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;destruct A&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; destruct B&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A * a = <span class="keyword">new</span> B;</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>输出：<br>destruct B<br>destruct A</p><p>将基类的析构函数声明为虚函数时，该基类的所有派生类的析构函数都自动成为虚函数（即使派生类的析构函数与基类的析构函数名字不相同），且构成多态。所以会调用子类B的析构函数，从而再自动调用基类析构函数。</p></blockquote><div class="note info modern"><p><strong>所以，当一个类被用作其它类的基类时，建议将它的析构函数设置为virtual。</strong></p></div><h3 id="5-纯虚函数"><a href="#5-纯虚函数" class="headerlink" title="5. 纯虚函数"></a>5. <strong>纯虚函数</strong></h3><p>纯虚函数：在声明虚函数时被“初始化”为0的函数。</p><blockquote><p>格式：virtual 函数类型 函数名（参数列表）= 0；</p></blockquote><div class="note warning modern"><ul><li>纯虚函数没有函数体；最后面的“=0”只起形式上的作用，告诉编译系统“这是纯虚函数”，并不表示返回值为0</li><li>这是一个声明语句，最后结尾有“；”</li><li>纯虚函数只有函数的名字而不具备函数的功能，因此不能被调用，在派生类中对此函数进行定义后，它才具备函数功能，可以被调用。</li><li>如果在一个类中声明了纯虚函数，而在其派生类中没有对该函数定义，则该虚函数在派生类中仍然为纯虚函数</li></ul></div><p>纯虚函数的作用：是在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义，从而实现动态多态性。</p><h3 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6. 抽象类"></a>6. <strong>抽象类</strong></h3><p>抽象类：不用来定义对象而只作为一种基本类型用作继承的类。</p><ul><li><p>凡是包含纯虚函数的类都是抽象类。纯虚函数不能被调用，所以<code>抽象类无法建立对象</code>。</p></li><li><p>派生类中没有对所有纯虚函数进行定义–则此派生类仍然是抽象类，不能用来定义对象。在抽象类所派生出的新类中对基类的所有纯虚函数进行了定义后，派生类才不是抽象类，可以用来定义对象。</p></li><li><p><strong>抽象类不能定义对象(或者说抽象类不能实例化)，但是可以定义指向抽象类数据的<code>指针变量</code>。</strong></p></li><li><p>当派生类成为具体类之后，就可以用这种指针指向派生类对象，然后通过该指针调用虚函数，实现多态性的操作。</p></li></ul><p><strong>虚函数与纯虚函数的区别</strong></p><p>定义一个函数为虚函数，<code>不代表</code>函数是不被实现的函数。定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</p><p>定义一个函数为纯虚函数，代表<code>函数没有被实现</code>。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p><h3 id="C-中重载-重写总结"><a href="#C-中重载-重写总结" class="headerlink" title="C++中重载,重写总结"></a><strong>C++中重载,重写总结</strong></h3><p><strong>1. 继承: 一个新类从已有的类那里获得其已有成员。</strong></p><ul><li>当子类继承父类时，会将父类的全部成员（除了构造函数和析构函数以外的属性，方法）全部复制一份，作为子类的成员。</li><li>子类会标记从父类中继承的成员。这里可以简单的认为将子类本身的成员存在子类域，从父类复制过来的存在父类域</li></ul><p><strong>2. 向上转型(子类转换成基类)</strong></p><ul><li>子类对象赋值给基类，属于赋值运算，实际上是将子类的属性值赋值给基类。</li><li>子类对象赋值给基类的引用，引用不是子类对象的别名，只是子类对象的基类域的别名。</li><li>子类对象的地址赋值给基类指针，此指针仅指向子类的基类域部分。</li></ul><p>综上所述，子类对象向上转型成基类后，始终只能调用基类函数(情况1)或子类对象中<code>基类域</code>部分的数据成员与成员函数(情况2、3，且无虚函数的情况下)。</p><p><strong>3. 重载: 用同一个函数名定义多个函数，而这些的参数列表不同(个数，类型，顺序)。</strong></p><p>重载的注意点：</p><ol><li>重载函数之间的区别是参数列表，与返回值无关(函数调用时只需要函数名与参数)。</li><li>参数列表中的顺序指的是不同类型参数之间的顺序。例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> c, <span class="keyword">int</span> b)</span></span>;<span class="comment">//参数顺序为( int , char ,int )</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;<span class="comment">//参数顺序为( char , int ,int ),所以构成重载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">char</span> c, <span class="keyword">int</span> a)</span></span>;<span class="comment">//参数顺序为( int , char ,int )，不能构成重载，报错</span></span><br></pre></td></tr></table></figure><ol start="3"><li>只有在<code>同一个作用域</code>内才能构成重载。例如同一个类内，或者几个同名函数都是全局函数。注意：继承的子类中与父类域中的同名函数不构成重载(实际为隐藏关系，即子类中的同名函数会屏蔽掉基类中的同名函数)。</li><li>修饰函数的virtual 关键字对同类中函数的重载没有影响。</li></ol><p>vitrual的作用：子类中通过重写虚函数来实现对基类虚函数函数指针的覆盖。所以，virtual函数只有在继承中才有作用，同一个类中函数的重载判定条件不包括virtual修饰符。</p><p><strong>4. 重定义(产生隐藏现象)</strong></p><p>子类重新定义父类中有相同名称的<code>非虚函数</code> ( 参数列表可以不同 ) 。通过<code>子类对象</code>调用函数时，子类的函数屏蔽了与其同名的基类函数（Java中会构成重载，而C++中会构成隐藏现象）。</p><p>隐藏的注意点：</p><ol><li>隐藏仅限于<code>子类对象</code>，是子类<code>对象</code>调用与基类同名的函数时会屏蔽基类域中的同名函数，即调用的是子类中定义的函数，而不调用基类域中的同名函数；要想使用基类域中的方法必须通过::运算符。</li><li>同名的函数不在同一个作用域，分别位于子类与基类；</li><li>函数名相同，返回值和参数可以不同；</li><li>子类中的同名函数不管参数是否与之相同，只要是子类对象对此函数的调用，基类的函数都将被隐藏；</li><li>子类对象向上转型后，赋值给基类对象/(基类引用/基类指针)，通过基类对象/(引用/指针)，调用的仍然是基类(基类域)中的函数（参考向上转型）。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>&#123;</span><span class="comment">//定义父类Parent</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; cout&lt;&lt;“fa out!”&lt;&lt;endl; &#125;<span class="comment">//定义函数show()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Parent&#123;<span class="comment">//定义子类Son</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; cout&lt;&lt;“son out include i!”&lt;&lt;endl; &#125; <span class="comment">//子类中定义show(int)函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; cout&lt;&lt;“son out!”&lt;&lt;endl; &#125; <span class="comment">//子类中定义函数show()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Parent f, *pf;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">show</span>(<span class="number">12</span>); <span class="comment">//子类对象调用函数</span></span><br><span class="line">s.<span class="built_in">show</span>(); <span class="comment">//同上</span></span><br><span class="line"><span class="comment">//下面的语句为向上转型，从运行结果可以看到，它们都调用了基类函数。</span></span><br><span class="line">f=s;        f.<span class="built_in">show</span>(); </span><br><span class="line">Parent &amp;fy=s;    fy.<span class="built_in">show</span>();</span><br><span class="line">pf=&amp;s;      pf-&gt;<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 重写</strong></p><p>基类函数有<code>virtual</code>修饰，子类中的函数与基类名称相同，参数相同(一般返回类型也相同)，此为重写。</p><p>多态：基类中声明为virtual的函数，在子类中重写一个返回类型、名称、参数都相同的函数。在将子类<code>对象地址</code>/对象赋值给<code>基类指针</code>/基类引用后，通过基类指针/引用可以调用子类中重写的函数。</p><p>注意：基类中的虚函数，其子类中的重写函数会自动成为虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>&#123;</span><span class="comment">//定义基类fa</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;cout&lt;&lt;“Parent cout!”&lt;&lt;endl; &#125;   &#125;; <span class="comment">//定义虚函数show</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Parent&#123; <span class="comment">//定义子类son</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//show(int)因为参数不同，实际上并没有与基类中的show构成重写关系</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;  cout&lt;&lt;“Son cout include i!”&lt;&lt;endl;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;  cout&lt;&lt;“Son cout!”&lt;&lt;endl;    &#125; <span class="comment">//定义虚函数show，</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Parent f, *pf;      Son s; </span><br><span class="line">    f=s; <span class="comment">//s赋值给基类对象f</span></span><br><span class="line">    f.<span class="built_in">show</span>(); <span class="comment">//通过对象，调用的是基类中的show函数。</span></span><br><span class="line">    <span class="comment">//f.show(12); //错误,提示找不到与fa::show(int)匹配的函数</span></span><br><span class="line">    pf=&amp;s; <span class="comment">//将子类s的地址赋值给基类指针pf</span></span><br><span class="line">    pf-&gt;<span class="built_in">show</span>(); <span class="comment">//通过指针，调用的是子类中定义的show函数</span></span><br><span class="line">    <span class="comment">//pf-&gt;show(12); //错误,提示找不到fa::show(int)匹配的函数</span></span><br><span class="line">    Parent &amp;pa=s;<span class="comment">//定义基类引用并用子对象初始化</span></span><br><span class="line">    pa.<span class="built_in">show</span>();  <span class="comment">//通过引用实现多态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. 多态</strong></p><p>编译时多态：重载，在编译阶段可以通过参数类型确定调用的函数。<br>运行时多态：在程序执行中，将子类对象的地址赋值给基类指针后，程序才知道调用哪个子类的虚函数。</p><h3 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h3><ul><li><p>对虚函数的调用（ ）。<code>不一定使用动态联编</code></p><blockquote><p>虚函数在运行阶段和类的对象绑定在一起，这样成为动态联编。虚函数声明只能出现在类声明中虚函数原型中，而不能在成员的函数体实现的时候。必须由成员函数来调用或者通过指针、引用来访问虚函数。如果通过对象名来访问虚函数，则联编在编译过程中认为足静态联编。</p></blockquote></li><li><p>在C++中，<code>虚函数</code>用于实现运行时多态性。</p></li><li><p>  编译时的多态性可以通过使用 ( ) 获得。<code>虚函数和对象</code></p></li><li><p>静态联编所支持的多态性称为__<code>编译时</code>_<em>多态性,动态联编所支持的多态性则称为</em><code>运行时</code>__多态性。</p></li><li><p>c++中基类中只有带参数的构造函数时，派生类中一定要显示定义构造函数，并写出基类的构造函数及参数  √</p><p>即使基类的构造函数没有参数，派生类也必须建立构造函数 ×</p></li><li><p>在析构函数中调用虚函数时,采用____联编。<code>静态</code></p></li></ul><h1 id="第13章-输入输出流"><a href="#第13章-输入输出流" class="headerlink" title="第13章-输入输出流"></a>第13章-输入输出流</h1><h3 id="1-C-的输入输出流"><a href="#1-C-的输入输出流" class="headerlink" title="1. C++的输入输出流"></a>1. <strong>C++的输入输出流</strong></h3><p>输入输出流：由若干字节组成的字节序列，这些字节中的数据按顺序从一个对象传送到另一对象。</p><p>流中的内容可以是ASCII字符、二进制数值、图形图像、数字音频视频或其他形式的信息。</p><p>C++中，输入输出流被定义为流类。用流类定义的对象称为流对象。例如：cin、cout。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TB;</span><br><span class="line">  ios&#x2F;&#x2F;抽象基类--&gt;istream&#x2F;&#x2F;通用输入类</span><br><span class="line">  ios&#x2F;&#x2F;抽象基类--&gt;ostream&#x2F;&#x2F;通用输出类</span><br><span class="line">  istream&#x2F;&#x2F;通用输入类--&gt;ifstream&#x2F;&#x2F;输入文件流类</span><br><span class="line">  istream&#x2F;&#x2F;通用输入类--&gt;iostream&#x2F;&#x2F;通用输入输出类</span><br><span class="line">  ostream&#x2F;&#x2F;通用输出类--&gt;ofstream&#x2F;&#x2F;输出文件流类</span><br><span class="line">  ostream&#x2F;&#x2F;通用输出类--&gt;iostream&#x2F;&#x2F;通用输入输出类</span><br><span class="line">  iostream&#x2F;&#x2F;通用输入输出类--&gt;fstream</span><br></pre></td></tr></table></figure><p>注：<code>通用</code>IO流类在头文件iostream中声明，<code>文件</code>流类在头文件fstream中声明。</p><p>流类库中不同的类的声明被放在不同的头文件中，常用的头文件有：</p><p><code>#include &lt;iostream&gt;</code>      此头文件中包含了流常用类和对象，例如istream、ostream、iostream等类，cin、cout等对象。</p><p><code>#include &lt; fstream&gt;</code>       用于用户管理的文件的I/O操作。</p><p><code>#include &lt; strstream&gt;</code>    用于字符串流I/O。</p><p><code>#include &lt; stdiostream&gt;</code>   用于混合使用C和C++的I/O机制时。</p><p><code>#include &lt; iomanip&gt;</code>    在使用格式化I/O时应包含此头文件。</p><h3 id="2-标准输入流"><a href="#2-标准输入流" class="headerlink" title="2. 标准输入流"></a>2. <strong>标准输入流</strong></h3><ul><li><code>istream::get()</code>：读入一个字符，包括如下函数。</li></ul><ol><li><code>int get()</code>：从输入流中提取一个字符，函数返回值就是此字符。</li><li><code>istream&amp; get(char&amp; ch)</code>：从输入流中提取一个字符，赋给字符变量ch</li><li><code>istream&amp; get(char* s, streamsize n );</code>从输入流中读取n-1个字符（第n个是’\0’），赋值给参数中的字符数组或字符指针，结束条件为count个字符或者遇到回车符。默认终止符为回车。</li><li><code>istream&amp; get(char* s, streamsize n, char delim );</code>同上，若在读取n-1个字符之前若遇到终止符delim，则结束读取过程。</li></ol><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>]=“”; <span class="comment">//通过输入10个字符来初始化数组。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) <span class="comment">//下面个函数任选其一</span></span><br><span class="line">    ch[i]=cin.<span class="built_in">get</span>()/cin.<span class="built_in">get</span>(ch[i]);</span><br></pre></td></tr></table></figure><ul><li><code>istream::getline()</code>：读入<code>一行</code>字符<ul><li><code>istream&amp; getline (char* s, streamsize n );</code></li></ul>从输入流中读取字符，并保存至字符数组s中(数组以‘\0’结束)，默认结束符为‘\n‘，即输入回车后结束输入。字符数超过n，只取前n-1个字符。注：<code>只能输入一行</code>。<ul><li><code>istream&amp; getline (char* s, streamsize n, char delim );</code></li></ul>同上，但结束条件不同。若没有遇到结束符，则输满n-1个字符结束(最后一个为‘\0’)，回车并不会结束输入，只是作为其中的一个字符，所以<code>可以输入多行</code>。若遇到结束符delim，回车后结束输入，且只取delim之前的字符。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">cin.<span class="built_in">getline</span>(ch,<span class="number">10</span>,<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">cout&lt;&lt;ch;</span><br><span class="line">输入:<span class="number">000</span></span><br><span class="line">    <span class="number">000</span></span><br><span class="line">    <span class="number">012</span> <span class="comment">//连回车符一共输入12个字符，多行。</span></span><br><span class="line">输出:<span class="number">000</span></span><br><span class="line">    <span class="number">000</span></span><br><span class="line">    <span class="number">0</span>   <span class="comment">//一共输出9个字符: 000 000+回车 0+’\0’  ( 第十个是’\0’)</span></span><br></pre></td></tr></table></figure><p><strong>例：istream:: getline()函数连续输入。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>] , ch1[<span class="number">10</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(ch,<span class="number">10</span>);<span class="comment">//第一次输入</span></span><br><span class="line">cin.<span class="built_in">getline</span>(ch1,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><div class="note warning modern"><p>注意：若第一次输入的长度超过10，则第二个输入语句不执行，解决方法：</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[<span class="number">10</span>] , ch1[<span class="number">10</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(ch,<span class="number">10</span>);<span class="comment">//第一次输入</span></span><br><span class="line">cin.<span class="built_in">clear</span>(); <span class="comment">//清除所有错误状态标志，将状态恢复为可读写状态</span></span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">1000</span>,‘\n’); <span class="comment">//clear不会清除多余字符</span></span><br><span class="line">cin.<span class="built_in">getline</span>(ch1,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>ignore()函数：</p><p>原型：<code>istream&amp; ignore(streamsize count, int delim )</code></p><p>函数功能：从输入流忽略并舍弃字符，直至并包含 delim。</p><p>参数：</p><p><code>count</code>：要忽略的字符数，默认为1。</p><p><code>delim</code>：忽略终止的分隔字符。此字符也会被忽略舍弃掉。默认为EOF。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">1024</span>,’\n’);</span><br><span class="line"><span class="comment">//忽略输入流中1024个字符，或者遇到回车符(即使不满1024个字符)就终止忽略。</span></span><br></pre></td></tr></table></figure><ul><li><strong>c++标准库中全局函数getline</strong></li></ul><p>原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp; is, string&amp; str)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp; is, string&amp; str, <span class="keyword">char</span> delim )</span></span>;</span><br></pre></td></tr></table></figure><p><code>getline(cin,str)</code>是一个全局函数，属于string类。所以使用该函数的时候需<code>#include &lt;string&gt;</code>。</p><p>功能：从输入流中读入字符（包括空格等），存到string变量，直到出现以下情况为止：</p><ol><li>读到一个新行</li><li>读入了文件结束标志</li></ol><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string st;</span><br><span class="line"><span class="built_in">getline</span>(cin,st);</span><br></pre></td></tr></table></figure><h3 id="3-对数据文件的操作与文件流"><a href="#3-对数据文件的操作与文件流" class="headerlink" title="3. 对数据文件的操作与文件流"></a>3. <strong>对数据文件的操作与文件流</strong></h3><p>用于文件操作的文件流类:</p><ol><li>ifstream类：从istream类派生。 用来支持从磁盘文件的输入。</li><li>ofstream类：从ostream类派生。 用来支持向磁盘文件的输出。</li><li>fstream类：iostream类派生。 用来支持对磁盘文件的<code>输入输出</code>。</li></ol><p>对文件操作，须先定义一个文件流类对象（C语言中定义FILE指针），通过文件流对象访问文件中的数据。例如：<br><code>ostream outfile;    //定义输出文件流对象</code></p><div class="note waning modern"><p>注意：若需要使用文件流类，在头文件需包含fstream。<code>#include &lt;fstream&gt;</code></p></div><ul><li><strong>打开磁盘文件的两种方式</strong></li></ul><ol><li>调用文件流的成员函数open,形式为:<blockquote><p>文件流对象.open(磁盘文件名，输入输出方式);</p></blockquote></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ofstream outfile;</span><br><span class="line">outfile.<span class="built_in">open</span>(″f1.dat″,ios::out);<span class="comment">//相对路径，默认当前项目根目录</span></span><br><span class="line"><span class="comment">//outfile.open(″C:\\f1.dat″,ios::out); //绝对路径</span></span><br></pre></td></tr></table></figure><ol start="2"><li>定义文件流对象时指定参数(常用)</li></ol><p>文件流类的带参数的构造函数中包含了打开磁盘文件的功能。因此，可以通过调用此构造函数来实现打开文件的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(″f1.dat″,ios::out)</span></span>;<span class="comment">//以输出方式打开</span></span><br></pre></td></tr></table></figure><ul><li><strong>关闭磁盘文件</strong></li></ul><p>关闭文件用成员函数close。如: <code>outfile.close( );</code></p><ul><li><p><strong>输入输出方式: 在ios类中定义的枚举常量</strong></p><p><code>app</code>:以追加的模式打开文件。</p><p><code>binary</code>：二进制形式访问模式。</p><p><code>in</code>：输入模式，文件不存在，则打开失败。</p></li></ul><p>所以判断文件是否存在可以如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>,ios::in)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!fin)&#123;…&#125;<span class="comment">//!fin为真表示文件不存在</span></span><br></pre></td></tr></table></figure><pre><code>   `out`：输出模式，若文件存在，则清除原有内容。  `trunc`：如文件存在，则打开后清空文件，不存在，则新建文件。   `ate`：文件打开后定位到文件尾，ios:app就包含有此属性</code></pre><p>  注：可以用’|’将属性连接起来，表示或的关系。例：<code>ios::out|ios::binary</code></p><h3 id="4-对ASCII文件的操作"><a href="#4-对ASCII文件的操作" class="headerlink" title="4. 对ASCII文件的操作"></a>4. <strong>对ASCII文件的操作</strong></h3><p>ASCII文件(字符文件)：文件的每一个字节中均以ASCII代码形式存放数据，即一个字节存放一个字符 。</p><p>对ASCII文件的读写操作: </p><ol><li><p>用流插入运算符“&lt;&lt;”和流提取运算符“&gt;&gt;”输入输出标准类型的数据.</p><p>特征：分隔符为空格、制表符等，所以每次只能访问一个成员。若字符串若包含空格，不能正常读取。</p></li><li><p>用文件流的get,geiline等成员函数访问文件。</p><p>特征：都以字符形式读入，例如一次读一行。存放数据的为字符数组，成员的处理没有方法1的灵活。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">80</span>];</span><br><span class="line">    <span class="function">ofstream <span class="title">SaveFile</span><span class="params">(<span class="string">&quot;d:\\ioftest.txt&quot;</span>,ios::out)</span></span>;</span><br><span class="line">    SaveFile &lt;&lt; <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    SaveFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;d:\\ioftest.txt&quot;</span>,ios::in)</span></span>;</span><br><span class="line">    ifs.<span class="built_in">getline</span>(ch,<span class="number">80</span>);<span class="comment">//getline(ifs,str);也可以使用</span></span><br><span class="line">    cout&lt;&lt;ch;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-对二进制文件的操作"><a href="#5-对二进制文件的操作" class="headerlink" title="5. 对二进制文件的操作"></a>5. <strong>对二进制文件的操作</strong></h3><p>二进制文件：文件中的数据以字节形式存放。又称为字节文件。</p><p>需要先打开文件，用完后要关闭文件。打开时输入输出方式要用“ios::binary”，指定为以二进制形式访问。</p><p>用成员函数read和write读写二进制文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">write</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * buffer, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function">istream &amp; <span class="title">read</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>字符指针buffer指向内存中一段存储空间。len是读写的字节数。调用的方式为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. <span class="built_in">write</span>(p1,<span class="number">50</span>); <span class="comment">//a是输出文件流,将p1输出到文件</span></span><br><span class="line">b. <span class="built_in">read</span>(p2,<span class="number">30</span>);  <span class="comment">//b是输入文件流,将数据读入p2</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">80</span>];</span><br><span class="line">    <span class="function">ofstream <span class="title">SaveFile</span><span class="params">(<span class="string">&quot;d:\\ioftest.txt&quot;</span>,ios::binary)</span></span>;</span><br><span class="line">    SaveFile.<span class="built_in">write</span>(<span class="string">&quot;i am happy&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>)*<span class="number">11</span>);</span><br><span class="line">    SaveFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;d:\\ioftest.txt&quot;</span>,ios::binary)</span></span>;</span><br><span class="line">    ifs.<span class="built_in">read</span>(ch,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>)*<span class="number">11</span>);</span><br><span class="line">    cout&lt;&lt;ch;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-字符串流"><a href="#6-字符串流" class="headerlink" title="6. 字符串流"></a>6. <strong>字符串流</strong></h3><p>字符串流：以内存中用户定义的字符数组(字符串)为输入输出的对象，即将数据输出到内存中的字符数组，或者从字符数组(字符串)将数据读入。字符串流也称为内存流。</p><p>使用注意:</p><ol><li>输出时数据不是流向外存文件，而是流向内存中的一个存储空间。输入时从内存中的存储空间读取数据。 </li><li>字符串流对象关联的不是文件，而是内存中的一个字符数组，因此不需要打开和关闭文件。</li><li>每个文件的最后都有一个文件结束符，表示文件的结束。而字符串流所关联的字符数组中没有相应的结束标志，用户要指定一个特殊字符作为结束符，在向字符数组写入全部数据后要写入此字符。</li></ol><ul><li><strong>建立输出字符串流对象</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ostrstream::<span class="built_in">ostrstream</span>(<span class="keyword">char</span> *buffer,<span class="keyword">int</span> n,<span class="keyword">int</span> mode=ios::out);</span><br></pre></td></tr></table></figure><p>buffer是指向字符数组首元素的指针，n为指定的流缓冲区的大小，第3个参数是可选的，默认为ios::out方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostrstream <span class="title">strout</span><span class="params">(ch1,<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>建立输入字符串流对象</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istrstream::<span class="built_in">istrstream</span>(<span class="keyword">char</span> *buffer);</span><br><span class="line">istrstream::<span class="built_in">istrstream</span>(<span class="keyword">char</span> *buffer,<span class="keyword">int</span> n);</span><br></pre></td></tr></table></figure><p>buffer是指向字符数组首元素的指针，使流对象与字符数组建立关联。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istrstream <span class="title">strin</span><span class="params">(ch2)</span></span>; </span><br><span class="line"><span class="function">istrstream <span class="title">strin</span><span class="params">(ch2,<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>建立输入输出字符串流对象</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strstream::<span class="built_in">strstream</span>(<span class="keyword">char</span> *buffer,<span class="keyword">int</span> n,<span class="keyword">int</span> mode);</span><br><span class="line"><span class="function">strstream <span class="title">strio</span><span class="params">(ch3,<span class="keyword">sizeof</span>(ch3),ios::in|ios::out)</span></span>;</span><br></pre></td></tr></table></figure><p>注：以上3个字符串流类是在头文件strstream中定义的，在用到istrstream, ostrstream和strstream类时应包含头文件strstream。</p><h3 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h3><ul><li>已知int a, *pa=&a;输出指针pa十进制的地址值的方法是（ ）<code>cout&lt;&lt;long(&amp;pa);</code></li></ul><blockquote><p>插入符输出指针类型对象的地址值时，默认为十六进制形式。如果要输出十进制形式的地址值，必须用类型long进行强制。答案A,输出了指针pa本身的值,也即变量a的地址值。 答案B中输出了指针pa所指向的对象,即a的值。答案C，以十六进制形式输出指针pa的地址值。</p></blockquote><ul><li>若磁盘上已存在某个文本文件，它的全路径文件名为 d:\kaoshi\test.txt，则下列语句中不能打开这个文件的是（ ）。<code>ifstream file(“d:\kaoshi\test.txt”);</code></li></ul><blockquote><p>文件流的打开路径用“\”隔开，而不是“\”，但可以用“/”隔开。</p></blockquote><ul><li>下列函数中，（ ）是对文件进行写操作的。 <code>put()</code></li><li>当使用ifstream流类定义一个流对象并打开一个磁盘文件时，文件的隐含打开方式为（ ）。<code>ios::in</code></li><li>cin是<code>istream</code>类的一个对象，处理标准输入。cout、cerr、clog是<code>ostream</code>类的对象。</li><li>标准错误流的输出发送给流对象___<code>cerr</code><em><strong>或</strong></em><code>clog</code>___。</li><li>在C++中，打开一个文件就是将一个文件与一个___<code>流</code>______建立关联；关闭一个文件就是取消这种关联。</li></ul><h1 id="第14章-C-工具"><a href="#第14章-C-工具" class="headerlink" title="第14章-C++工具"></a>第14章-C++工具</h1><h3 id="1-异常处理"><a href="#1-异常处理" class="headerlink" title="1. 异常处理"></a>1. <strong>异常处理</strong></h3><p>程序中常见的错误有两大类: 语法错误（编译错误）和运行错误。</p><p>异常处理的任务：事先分析程序运行时可能出现的各种意外的情况，并且制订出相应的处理方法。</p><p>异常处理的方法: 出现异常→发出信息，传给它的上一级→上级捕捉到这个信息后进行处理→如果上一级的函数不能处理→再传给其上一级，由其上一级处理。如此逐级上送→如果到最高一级无法处理，则终止程序执行。</p><p>C++处理异常机制由3个部分组成：即检查(try)、抛出(throw)和捕捉(catch)。把需要检查的语句放在try块中，throw用来当出现异常时发出一个异常信息，而catch则用来捕捉异常信息并处理。</p><blockquote><p>语法：<br>        try{<br>            检查语句    // 若有异常，会执行throw 表达式;<br>        }<br>catch(异常信息类型 [变量名]) {<br>            进行异常处理的语句<br>}</p></blockquote><p>注意：</p><ol><li>被检测的函数必须放在try块中。</li><li>try块和catch块作为一个整体出现，在二者之间不能插入其他语句。但在一个try-catch结构中，可以只有try块而无catch块。</li><li>一个try-catch结构中只能有<code>一个try</code>块，但却可以有<code>多个catch块</code>。</li><li>catch后面的圆括号中,一般只写异常信息的类型名catch(int)。</li><li>如果在catch子句中没有指定异常信息的类型，而用 “…”，则表示它可以捕捉任何类型的异常信息。</li><li>try-catch结构可以与throw出现在同一个函数中，也可以不在同一函数中。当throw抛出异常信息后，首先在本函数中寻找与之匹配的catch，如果在本函数中无try-catch结构或找不到与之匹配的catch，就转到离开出现异常最近的try-catch结构去处理。</li><li>在某些情况下，在throw语句中可以不包括表达式，如throw;<br>表示“不处理这个异常，交给上一级处理”。</li><li>如果throw抛出的异常信息找不到与之匹配的catch块，那么系统就会调用一个系统函数terminate，使程序终止运行。</li></ol><h3 id="2-在异常处理中处理析构函数"><a href="#2-在异常处理中处理析构函数" class="headerlink" title="2. 在异常处理中处理析构函数"></a>2. <strong>在异常处理中处理析构函数</strong></h3><p>如果在try块中定义了类对象，在建立该对象时会调用类的构造函数。</p><p>在执行try块 (包括在try块中调用其他函数) 的过程中如果发生了异常，此时流程立即离开try块。</p><p>流程可能离开try中构建的对象的作用域而转到其他函数，应做好结束对象前的清理工作（析构函数）</p><p>C++的异常处理机制会在throw抛出异常信息被catch捕获时，<code>自动</code>对有关的局部对象进行析构(自动调用类对象的析构函数)， 析构对象的顺序与构造的顺序相反，然后执行与异常信息匹配的catch块中的语句。</p><h3 id="3-命名空间"><a href="#3-命名空间" class="headerlink" title="3. 命名空间"></a>3. <strong>命名空间</strong></h3><p>命名空间：一个由程序设计者命名的内存区域。根据需要指定一些有名字的空间域，把一些全局实体分别放在各个命名空间中，从而与其他全局实体分隔开来。</p><p>作用：处理程序中常见的同名冲突。</p><p><code>定义</code>命名空间的格式：</p><blockquote><p>​    namespace 名称{<br>​        成员；<br>​    }</p></blockquote><p>成员可以包括：变量(可以带有初始化)；常量；函数(可以是定义或声明)；结构体；类；模板；命名空间。</p><p><code>使用</code>命名空间成员的方法:</p><blockquote><p>命名空间名::命名空间成员名</p></blockquote><ul><li><p><strong>简化使用命名空间成员的方法</strong>：</p><ol><li><p>使用命名空间别名</p></li><li><p>使用“using 命名空间成员名”</p></li></ol><p>using后面的命名空间成员名必须是由命名空间限定的名字。例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ns1::fun;<span class="comment">//声明其后出现的fun是属于ns1中的fun</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">fun</span>(<span class="number">5</span>,<span class="number">3</span>)&lt;&lt;endl; <span class="comment">//fun函数相当于ns1::fun(5,3)</span></span><br></pre></td></tr></table></figure><p>注意: 在同一作用域中用using声明的不同命名空间的成员中不能有同名的成员。例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ns1::Stu;<span class="comment">//声明其后出现的Stu是ns1中的Stu</span></span><br><span class="line"><span class="keyword">using</span> ns2::Stu; <span class="comment">//声明其后出现的Stu是ns2中的Stu</span></span><br><span class="line">Stu stud1; <span class="comment">//产生了二义性，编译出错。</span></span><br></pre></td></tr></table></figure><p>using声明的有效范围是从using语句开始到using所在的作用域结束。</p><ol start="3"><li>使用“using namespace 命名空间名;” </li></ol><p>用一个语句一次声明一个命名空间中的全部成员</p><p>格式:</p><blockquote><p>using namespace命名空间名；</p></blockquote><p>例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> ns1;</span><br></pre></td></tr></table></figure><p>声明了在本作用域中要用到命名空间ns1中的成员，在使用该命名空间的任何成员时都不必用命名空间限定。如果在作了上面的声明后有以下语句:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student隐含指命名空间ns1中的Student</span></span><br><span class="line"><span class="function">Student <span class="title">stud1</span><span class="params">(<span class="number">101</span>,″Wang″,<span class="number">18</span>)</span></span>; </span><br><span class="line"><span class="comment">//这里的fun函数是命名空间ns1中的fun函数</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">fun</span>(<span class="number">5</span>,<span class="number">3</span>)&lt;&lt;endl;          </span><br></pre></td></tr></table></figure></li></ul><h3 id="4-标准命名空间std"><a href="#4-标准命名空间std" class="headerlink" title="4. 标准命名空间std"></a>4. <strong>标准命名空间std</strong></h3><p>标准C++库的所有的标识符都是在一个名为std的命名空间中定义的，或者说标准头文件(如iostream)中的函数、类、对象和类模板是定义在命名空间std中。</p><p>在程序中用到C++标准库时，需要使用std作为限定。</p><p><code>std::cout&lt;&lt;″OK.″&lt;&lt;endl; </code></p><p>在文件的开头加入以下using namespace声明:  </p><p><code>using namespace std;</code></p><p>在std中定义和声明的所有标识符在本文件中都可以作为全局量来使用。但是应当绝对保证在程序中不出现与命名空间std的成员同名的标识符。</p><h3 id="5-使用早期的函数库"><a href="#5-使用早期的函数库" class="headerlink" title="5. 使用早期的函数库"></a>5. <strong>使用早期的函数库</strong></h3><ol><li><p>用C语言的传统方法。头文件名包括后缀.h</p></li><li><p>用C++的新方法。C++系统提供的头文件不包括后缀.h，例如iostream。C++所用的头文件名是在C语言的相应的头文件名(但不包括后缀.h)之前加一字母c。且这些函数都是在命名空间std中声明的，所以需在程序中声明std。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure></li></ol><p>大多数C++编译系统既保留了C的用法，又提供了C++的新方法。下面两种用法等价</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C传统方法 </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C++新方法</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
